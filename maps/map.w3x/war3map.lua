udg_UnitMovingInList = __jarray(false)
udg_UMovNext = __jarray(0)
udg_UMovPrev = __jarray(0)
udg_TempX = 0.0
udg_TempY = 0.0
udg_UnitMoving = __jarray(false)
udg_UnitMovingEvent = 0.0
udg_UnitMovingX = __jarray(0.0)
udg_UnitMovingY = __jarray(0.0)
udg_UDex = 0
udg_UDexUnits = {}
udg_Timestamp = nil
udg_DmgStr = ""
udg_AOEString = ""
udg_Reporting = false
udg_ReportLife = 0.0
udg_DamageEventArmorPierced = 0.0
udg_DamageEventOverride = false
udg_DamageEventAmount = 0.0
udg_DamageEventSource = nil
udg_DamageEventTarget = nil
udg_DamageEventPrevAmt = 0.0
udg_LethalDamageHP = 0.0
udg_AOEDamageSource = nil
udg_DamageEventAOE = 0
udg_DamageEventAOEGroup = nil
udg_DamageEventLevel = 0
udg_EnhancedDamageTarget = nil
udg_DamageEventType = 0
udg_NextDamageType = 0
udg_DamageScalingUser = 0.0
udg_DamageScalingWC3 = 0.0
udg_DamageTypeBlocked = 0
udg_DamageTypeCriticalStrike = 0
udg_DamageTypeCode = 0
udg_DamageTypeExplosive = 0
udg_DamageTypeHeal = 0
udg_DamageTypePure = 0
udg_DamageTypePureExplosive = 0
udg_DamageTypeReduced = 0
udg_IsDamageCode = false
udg_IsDamageMelee = false
udg_IsDamageRanged = false
udg_IsDamageSpell = false
udg_DamageEventTrigger = nil
udg_DamageEventArmorT = 0
udg_ARMOR_TYPE_NONE = 0
udg_ARMOR_TYPE_FLESH = 0
udg_ARMOR_TYPE_METAL = 0
udg_ARMOR_TYPE_WOOD = 0
udg_ARMOR_TYPE_ETHEREAL = 0
udg_ARMOR_TYPE_STONE = 0
udg_ArmorTypeDebugStr = __jarray("")
udg_DamageEventAttackT = 0
udg_ATTACK_TYPE_SPELLS = 0
udg_ATTACK_TYPE_NORMAL = 0
udg_ATTACK_TYPE_PIERCE = 0
udg_ATTACK_TYPE_SIEGE = 0
udg_ATTACK_TYPE_MAGIC = 0
udg_ATTACK_TYPE_CHAOS = 0
udg_ATTACK_TYPE_HERO = 0
udg_AttackTypeDebugStr = __jarray("")
udg_DamageEventDamageT = 0
udg_DAMAGE_TYPE_UNKNOWN = 0
udg_DAMAGE_TYPE_NORMAL = 0
udg_DAMAGE_TYPE_ENHANCED = 0
udg_DAMAGE_TYPE_FIRE = 0
udg_DAMAGE_TYPE_COLD = 0
udg_DAMAGE_TYPE_LIGHTNING = 0
udg_DAMAGE_TYPE_POISON = 0
udg_DAMAGE_TYPE_DISEASE = 0
udg_DAMAGE_TYPE_DIVINE = 0
udg_DAMAGE_TYPE_MAGIC = 0
udg_DAMAGE_TYPE_SONIC = 0
udg_DAMAGE_TYPE_ACID = 0
udg_DAMAGE_TYPE_FORCE = 0
udg_DAMAGE_TYPE_DEATH = 0
udg_DAMAGE_TYPE_MIND = 0
udg_DAMAGE_TYPE_PLANT = 0
udg_DAMAGE_TYPE_DEFENSIVE = 0
udg_DAMAGE_TYPE_DEMOLITION = 0
udg_DAMAGE_TYPE_SLOW_POISON = 0
udg_DAMAGE_TYPE_SPIRIT_LINK = 0
udg_DAMAGE_TYPE_SHADOW_STRIKE = 0
udg_DAMAGE_TYPE_UNIVERSAL = 0
udg_DamageTypeDebugStr = __jarray("")
udg_DamageEventDefenseT = 0
udg_DEFENSE_TYPE_LIGHT = 0
udg_DEFENSE_TYPE_MEDIUM = 0
udg_DEFENSE_TYPE_HEAVY = 0
udg_DEFENSE_TYPE_FORTIFIED = 0
udg_DEFENSE_TYPE_NORMAL = 0
udg_DEFENSE_TYPE_HERO = 0
udg_DEFENSE_TYPE_DIVINE = 0
udg_DEFENSE_TYPE_UNARMORED = 0
udg_DefenseTypeDebugStr = __jarray("")
udg_WeaponTypeDebugStr = __jarray("")
udg_WEAPON_TYPE_NONE = 0
udg_WEAPON_TYPE_ML_CHOP = 0
udg_WEAPON_TYPE_MM_CHOP = 0
udg_WEAPON_TYPE_MH_CHOP = 0
udg_WEAPON_TYPE_ML_SLICE = 0
udg_WEAPON_TYPE_MM_SLICE = 0
udg_WEAPON_TYPE_MH_SLICE = 0
udg_WEAPON_TYPE_MM_BASH = 0
udg_WEAPON_TYPE_MH_BASH = 0
udg_WEAPON_TYPE_MM_STAB = 0
udg_WEAPON_TYPE_MH_STAB = 0
udg_WEAPON_TYPE_WL_SLICE = 0
udg_WEAPON_TYPE_WM_SLICE = 0
udg_WEAPON_TYPE_WH_SLICE = 0
udg_WEAPON_TYPE_WL_BASH = 0
udg_WEAPON_TYPE_WM_BASH = 0
udg_WEAPON_TYPE_WH_BASH = 0
udg_WEAPON_TYPE_WL_STAB = 0
udg_WEAPON_TYPE_WM_STAB = 0
udg_WEAPON_TYPE_CL_SLICE = 0
udg_WEAPON_TYPE_CM_SLICE = 0
udg_WEAPON_TYPE_CH_SLICE = 0
udg_WEAPON_TYPE_AM_CHOP = 0
udg_WEAPON_TYPE_RH_BASH = 0
udg_DamageEventWeaponT = 0
udg_IsUnitPreplaced = __jarray(false)
udg_CONVERTED_ATTACK_TYPE = {}
udg_CONVERTED_DAMAGE_TYPE = {}
udg_TempGroup = nil
gg_trg_Damage_Engine_Config = nil
gg_trg_Is_Unit_Moving = nil
gg_trg_Unit_Moving_Index = nil
gg_trg_Unit_Indexer_Event = nil
gg_trg_Opening_Text = nil
gg_trg_Set_Damage = nil
gg_trg_Prevent_Lethal = nil
gg_trg_Damage_Tag = nil
gg_trg_On_AOE = nil
gg_trg_On_Zero = nil
gg_trg_Damage_Report = nil
gg_trg_AfterDamageEvent = nil
gg_trg_Report_On_Off = nil
gg_trg_Untitled_Trigger_001 = nil
gg_trg_Untitled_Trigger_003 = nil
gg_trg_Untitled_Trigger_003_Copy = nil
gg_trg_Untitled_Trigger_002 = nil
gg_trg_TestTrig = nil
gg_trg_Melee_Initialization = nil
gg_trg_StartResources = nil
gg_trg_DamageModifier = nil
gg_trg_DamageOnMovingUnit = nil
function InitGlobals()
    local i = 0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_UnitMovingInList[i] = false
        i = i + 1
    end
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_UMovNext[i] = 0
        i = i + 1
    end
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_UMovPrev[i] = 0
        i = i + 1
    end
    udg_TempX = 0.0
    udg_TempY = 0.0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_UnitMoving[i] = false
        i = i + 1
    end
    udg_UnitMovingEvent = 0.0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_UnitMovingX[i] = 0.0
        i = i + 1
    end
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_UnitMovingY[i] = 0.0
        i = i + 1
    end
    globals.udg_UnitIndexEvent = 0.0
    udg_UDex = 0
    udg_Timestamp = CreateTimer()
    udg_DmgStr = ""
    udg_AOEString = ""
    udg_Reporting = false
    udg_ReportLife = 0.0
    udg_DamageEventArmorPierced = 0.0
    globals.udg_AfterDamageEvent = 0.0
    udg_DamageEventOverride = false
    globals.udg_DamageEvent = 0.0
    globals.udg_DamageModifierEvent = 0.0
    udg_DamageEventAmount = 0.0
    udg_DamageEventPrevAmt = 0.0
    globals.udg_LethalDamageEvent = 0.0
    udg_LethalDamageHP = 0.0
    globals.udg_AOEDamageEvent = 0.0
    udg_DamageEventAOE = 0
    udg_DamageEventAOEGroup = CreateGroup()
    udg_DamageEventLevel = 0
    udg_DamageEventType = 0
    udg_NextDamageType = 0
    udg_DamageScalingUser = 0.0
    udg_DamageScalingWC3 = 0.0
    udg_DamageTypeBlocked = 0
    udg_DamageTypeCriticalStrike = 0
    udg_DamageTypeCode = 0
    udg_DamageTypeExplosive = 0
    udg_DamageTypeHeal = 0
    udg_DamageTypePure = 0
    udg_DamageTypePureExplosive = 0
    udg_DamageTypeReduced = 0
    udg_IsDamageCode = false
    udg_IsDamageMelee = false
    udg_IsDamageRanged = false
    udg_IsDamageSpell = false
    udg_DamageEventArmorT = 0
    udg_ARMOR_TYPE_NONE = 0
    udg_ARMOR_TYPE_FLESH = 0
    udg_ARMOR_TYPE_METAL = 0
    udg_ARMOR_TYPE_WOOD = 0
    udg_ARMOR_TYPE_ETHEREAL = 0
    udg_ARMOR_TYPE_STONE = 0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_ArmorTypeDebugStr[i] = ""
        i = i + 1
    end
    udg_DamageEventAttackT = 0
    udg_ATTACK_TYPE_SPELLS = 0
    udg_ATTACK_TYPE_NORMAL = 0
    udg_ATTACK_TYPE_PIERCE = 0
    udg_ATTACK_TYPE_SIEGE = 0
    udg_ATTACK_TYPE_MAGIC = 0
    udg_ATTACK_TYPE_CHAOS = 0
    udg_ATTACK_TYPE_HERO = 0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_AttackTypeDebugStr[i] = ""
        i = i + 1
    end
    udg_DamageEventDamageT = 0
    udg_DAMAGE_TYPE_UNKNOWN = 0
    udg_DAMAGE_TYPE_NORMAL = 0
    udg_DAMAGE_TYPE_ENHANCED = 0
    udg_DAMAGE_TYPE_FIRE = 0
    udg_DAMAGE_TYPE_COLD = 0
    udg_DAMAGE_TYPE_LIGHTNING = 0
    udg_DAMAGE_TYPE_POISON = 0
    udg_DAMAGE_TYPE_DISEASE = 0
    udg_DAMAGE_TYPE_DIVINE = 0
    udg_DAMAGE_TYPE_MAGIC = 0
    udg_DAMAGE_TYPE_SONIC = 0
    udg_DAMAGE_TYPE_ACID = 0
    udg_DAMAGE_TYPE_FORCE = 0
    udg_DAMAGE_TYPE_DEATH = 0
    udg_DAMAGE_TYPE_MIND = 0
    udg_DAMAGE_TYPE_PLANT = 0
    udg_DAMAGE_TYPE_DEFENSIVE = 0
    udg_DAMAGE_TYPE_DEMOLITION = 0
    udg_DAMAGE_TYPE_SLOW_POISON = 0
    udg_DAMAGE_TYPE_SPIRIT_LINK = 0
    udg_DAMAGE_TYPE_SHADOW_STRIKE = 0
    udg_DAMAGE_TYPE_UNIVERSAL = 0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_DamageTypeDebugStr[i] = ""
        i = i + 1
    end
    udg_DamageEventDefenseT = 0
    udg_DEFENSE_TYPE_LIGHT = 0
    udg_DEFENSE_TYPE_MEDIUM = 0
    udg_DEFENSE_TYPE_HEAVY = 0
    udg_DEFENSE_TYPE_FORTIFIED = 0
    udg_DEFENSE_TYPE_NORMAL = 0
    udg_DEFENSE_TYPE_HERO = 0
    udg_DEFENSE_TYPE_DIVINE = 0
    udg_DEFENSE_TYPE_UNARMORED = 0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_DefenseTypeDebugStr[i] = ""
        i = i + 1
    end
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_WeaponTypeDebugStr[i] = ""
        i = i + 1
    end
    udg_WEAPON_TYPE_NONE = 0
    udg_WEAPON_TYPE_ML_CHOP = 0
    udg_WEAPON_TYPE_MM_CHOP = 0
    udg_WEAPON_TYPE_MH_CHOP = 0
    udg_WEAPON_TYPE_ML_SLICE = 0
    udg_WEAPON_TYPE_MM_SLICE = 0
    udg_WEAPON_TYPE_MH_SLICE = 0
    udg_WEAPON_TYPE_MM_BASH = 0
    udg_WEAPON_TYPE_MH_BASH = 0
    udg_WEAPON_TYPE_MM_STAB = 0
    udg_WEAPON_TYPE_MH_STAB = 0
    udg_WEAPON_TYPE_WL_SLICE = 0
    udg_WEAPON_TYPE_WM_SLICE = 0
    udg_WEAPON_TYPE_WH_SLICE = 0
    udg_WEAPON_TYPE_WL_BASH = 0
    udg_WEAPON_TYPE_WM_BASH = 0
    udg_WEAPON_TYPE_WH_BASH = 0
    udg_WEAPON_TYPE_WL_STAB = 0
    udg_WEAPON_TYPE_WM_STAB = 0
    udg_WEAPON_TYPE_CL_SLICE = 0
    udg_WEAPON_TYPE_CM_SLICE = 0
    udg_WEAPON_TYPE_CH_SLICE = 0
    udg_WEAPON_TYPE_AM_CHOP = 0
    udg_WEAPON_TYPE_RH_BASH = 0
    udg_DamageEventWeaponT = 0
    i = 0
    while (true) do
        if ((i > 1)) then break end
        udg_IsUnitPreplaced[i] = false
        i = i + 1
    end
    udg_TempGroup = CreateGroup()
end

--Global Initialization 1.1 also hooks the InitCustomTriggers and RunInitializationTriggers functions
do
   local iFuncs = {}
   function onInitialization(func) -- Runs once all Map Initialization triggers are executed
      iFuncs[func] = func
   end
   local function runInitialization()
      for k, f in pairs(iFuncs) do f() end
      iFuncs = nil
   end
   
   local tFuncs = {}
   function onTriggerInit(func) -- Runs once all InitTrig_ functions are called
      tFuncs[func] = func
   end
   local function runTriggerInit()
      for k, f in pairs(tFuncs) do f() end
      tFuncs = nil
      local old = RunInitializationTriggers
      if old then
         function RunInitializationTriggers()
            old()
            runInitialization()
         end
      else
         runInitialization()
      end
   end
   
   local gFuncs = {}
   function onGlobalInit(func) --Runs once all udg_ globals are set.
      gFuncs[func] = func --Simplification thanks to TheReviewer and Zed on Hive Discord
   end
   local function runGlobalInit()
      for k, f in pairs(gFuncs) do f() end
      gFuncs = nil
      
      local old = InitCustomTriggers
      if old then
         function InitCustomTriggers()
            old()
            runTriggerInit()
         end
      else
         runTriggerInit()
      end
   end
   
   local oldBliz = InitBlizzard
   function InitBlizzard()
      oldBliz()
      local old = InitGlobals
      if old then
         function InitGlobals()
            old()
            runGlobalInit()
         end
      else
         runGlobalInit()
      end
   end
end
-- TriggerRegisterVariableEvent hook to convert these old school events into something more useful.

do
   events = {}
   function onRegisterVar(func)
      events[func] = func
   end
   
   local oldEvent = TriggerRegisterVariableEvent 
   function TriggerRegisterVariableEvent(trig, var, op, val)
      for k, func in pairs(events) do
         if func(trig, var, val) then return end
      end
      oldEvent(trig, var, op, val)
   end
end
--[[
===========================================================================
 Lua Version
 
 Damage Engine lets you detect, amplify, block or nullify damage. It even
 lets you detect if the damage was physical or from a spell. Just reference
 DamageEventAmount/Source/Target or the boolean IsDamageSpell, to get the
 necessary damage event data.
   
 - Detect damage (after it was dealt to the unit): use the event "DamageEvent Equal to 1.00"
 - To change damage before it is dealt: use the event "DamageModifierEvent Equal to 1.00"
 - Detect spell damage: use the condition "IsDamageSpell Equal to True"
 - Detect zero-damage: use the event "DamageEvent Equal to 2.00"
   
 You can specify the DamageEventType before dealing triggered damage:
 - Set NextDamageType = DamageTypeWhatever
 - Unit - Cause...
   
 You can modify the DamageEventAmount and the DamageEventType from a "DamageModifierEvent Equal to 1.00" trigger.
 - If the amount is modified to negative, it will count as a heal.
 - If the amount is set to 0, no damage will be dealt.
   
 If you need to reference the original in-game damage, use the variable "DamageEventPrevAmt".
 
GUI Vars:
   
   Retained from 3.8 and prior:
   ----------------------------
   unit           udg_DamageEventSource
   unit           udg_DamageEventTarget
   unit           udg_EnhancedDamageTarget
   group          udg_DamageEventAOEGroup
   integer        udg_DamageEventAOE
   integer        udg_DamageEventLevel
   real           udg_DamageModifierEvent
   real           udg_DamageEvent
   real           udg_AfterDamageEvent
   real           udg_DamageEventAmount
   real           udg_DamageEventPrevAmt
   real           udg_AOEDamageEvent
   boolean        udg_DamageEventOverride
   boolean        udg_NextDamageType
   boolean        udg_DamageEventType
   boolean        udg_IsDamageSpell
   
   Added in 5.0:
   boolean        udg_IsDamageMelee    
   boolean        udg_IsDamageRanged   
   unit           udg_AOEDamageSource   
   real           udg_LethalDamageEvent 
   real           udg_LethalDamageHP   
   real           udg_DamageScalingWC3
   integer        udg_DamageEventAttackT
   integer        udg_DamageEventDamageT
   integer        udg_DamageEventWeaponT
   
   Added in 5.1:
   boolean        udg_IsDamageCode   
   
   Added in 5.2:
   integer        udg_DamageEventArmorT  
   integer        udg_DamageEventDefenseT
   
   Addded in 5.3:
   real           DamageEventArmorPierced
   real           udg_DamageScalingUser  
   
   Added in 5.4.2 to allow GUI users to re-issue the exact same attack and damage type at the attacker.
   attacktype array udg_CONVERTED_ATTACK_TYPE
   damagetype array udg_CONVERTED_DAMAGE_TYPE
   
=============================================================================
--]]
 
do
   local alarm       = CreateTimer()
   local alarmSet    = false
   
   --Values to track the original pre-spirit Link/defensive damage values
   local canKick     = true
   local totem       = false
   local armorType   = 0
   local defenseType = 0
   local prev        = {}
   
   --Stuff to track recursive UnitDamageTarget calls.
   local eventsRun   = false
   local kicking     = false
   local stack       = {}
   
   --Added in 5.4 to silently eliminate infinite recursion.
   local userTrigs   = 9
   local eventTrig   = 0
   local nextTrig    = {}
   local userTrig    = {}
   local trigFrozen  = {}
   
   --Added/re-tooled in 5.4.1 to allow forced recursion (for advanced users only).
   local levelsDeep     = {}   --How deep the user recursion currently is.
   local LIMBO          = 16   --Recursion will never go deeper than LIMBO.
   DamageEngine_inception= false --You must set DamageEngine_inception = true before dealing damage to utlize this.
                          --When true, it allows your trigger to potentially go recursive up to LIMBO.
   local dreaming       = false
   local fischerMorrow  = {} --track targets of recursion
   local inceptionTrig  = {}   --Added in 5.4.2 to simplify the inception variable for very complex DamageEvent trigger.
   local proclusGlobal  = {} --track sources of recursion
   local sleepLevel     = 0
   
   --Improves readability in the code to have these as named constants.
   local event = {
      mod      = 1,
      shield   = 4,
      damage   = 5,
      zero     = 6,
      after    = 7,
      lethal   = 8,
      aoe      = 9
   }
   
   local function runTrigs(i)
      local cat = i
      dreaming = true
      --print("Running " .. cat)
      while (true) do
         i = nextTrig[i]
         if (i == 0)
           or (cat == event.mod and (udg_DamageEventOverride or udg_DamageEventType*udg_DamageEventType == 4))
           or (cat == event.shield and udg_DamageEventAmount <= 0.00)
           or (cat == event.lethal and udg_LethalDamageHP > 0.405) then
            break
         end
         if not trigFrozen[i] then
            eventTrig = i
            if RunTrigger then --Added 10 July 2019 to enable FastTriggers mode.
               RunTrigger(userTrig[i])
            elseif IsTriggerEnabled(userTrig[i])
              and TriggerEvaluate(userTrig[i]) then
               TriggerExecute(userTrig[i])
            end
            --print("Ran " .. i)
         end
      end
      --print("Ran")
      dreaming = false
   end
   
   local function onAOEEnd()
      if udg_DamageEventAOE > 1 then
         runTrigs(event.aoe)
         udg_DamageEventAOE   = 1
      end
      udg_DamageEventLevel    = 1
      udg_EnhancedDamageTarget= nil
      udg_AOEDamageSource     = nil
      GroupClear(udg_DamageEventAOEGroup)
   end
   
   local function afterDamage()
      if udg_DamageEventPrevAmt ~= 0.00 and udg_DamageEventDamageT ~= udg_DAMAGE_TYPE_UNKNOWN then
         runTrigs(event.after)
      end
   end
   
   local oldUDT = UnitDamageTarget
   
   local function finish()
      if eventsRun then
         --print "events ran"
         eventsRun = false
         afterDamage()
      end
      if canKick and not kicking then
         local n = #stack
         if n > 0 then
            kicking = true
            --print("Clearing Recursion: " .. n)
            local i = 0
            local open
            repeat
               sleepLevel = sleepLevel + 1
               repeat
                  i = i + 1 --Need to loop bottom to top to make sure damage order is preserved.
                  open = stack[i]
                  udg_NextDamageType = open.type
                  --print("Stacking on " .. open.amount)
                  oldUDT(open.source, open.target, open.amount, true, false, open.attack, open.damage, open.weapon)
                  afterDamage()
               until (i == n)
               --print("Exit at: " .. i)
               n = #stack
            until (i == n)
            --print("Terminate at: " .. i)
            sleepLevel = 0
            repeat
               open = stack[i].trig
               stack[i] = nil
               proclusGlobal[open] = nil
               fischerMorrow[open] = nil
               trigFrozen[open] = false -- Only re-enable recursive triggers AFTER all damage is dealt.
               levelsDeep[open] = 0 --Reset this stuff if the user tried some nonsense
               --print("unfreezing " .. open)
               i = i - 1
            until (i == 0)
            kicking = false
         end
      end
   end
   
   function UnitDamageTarget(src, tgt, amt, a, r, at, dt, wt)
      if udg_NextDamageType == 0 then
         udg_NextDamageType = udg_DamageTypeCode
      end
      local b = false
      if dreaming then
         if amt ~= 0.00 then
            -- Store triggered, recursive damage into a stack.
            -- This damage will be fired after the current damage instance has wrapped up its events.
            stack[#stack + 1] = {
               type     = udg_NextDamageType,
               source   = src,
               target   = tgt,
               amount   = amt,
               attack   = at,
               damage   = dt,
               weapon   = wt,
               trig     = eventTrig
            }
            --print("increasing damage stack: " .. #stack)
            
            -- Next block added in 5.4.1 to allow *some* control over whether recursion should kick
            -- in. Also it's important to track whether the source and target were both involved at
            -- some earlier point, so this is a more accurate and lenient method than before.
            DamageEngine_inception = DamageEngine_inception or inceptionTrig[eventTrig]
            
            local sg = proclusGlobal[eventTrig]
            if not sg then
               sg = {}
               proclusGlobal[eventTrig] = sg
            end
            sg[udg_DamageEventSource] = true
            
            local tg = fischerMorrow[eventTrig]
            if not tg then
               tg = {}
               fischerMorrow[eventTrig] = tg
            end
            tg[udg_DamageEventTarget] = true
            
            if kicking and sg[src] and tg[tgt] then
               if DamageEngine_inception and not trigFrozen[eventTrig] then
                  inceptionTrig[eventTrig] = true
                  if levelsDeep[eventTrig] < sleepLevel then
                     levelsDeep[eventTrig] = levelsDeep[eventTrig] + 1
                     if levelsDeep[eventTrig] >= LIMBO then
                        --print("freezing inception trig: " .. eventTrig)
                        trigFrozen[eventTrig] = true
                     end
                  end
               else
                  --print("freezing standard trig: " .. eventTrig)
                  trigFrozen[eventTrig] = true
               end
            end
         end
      else
         b = oldUDT(src, tgt, amt, a, r, at, dt, wt)
      end
      --print("setting inception to false")
      DamageEngine_inception = false
      udg_NextDamageType = 0
      if b and not dreaming then
         finish() -- Wrap up the outstanding damage instance right away.
      end
      return b
   end
   
   local function resetArmor()
      if udg_DamageEventArmorPierced ~= 0.00 then
         BlzSetUnitArmor(udg_DamageEventTarget, BlzGetUnitArmor(udg_DamageEventTarget) + udg_DamageEventArmorPierced)
      end
      if armorType ~= udg_DamageEventArmorT then
         BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_ARMOR_TYPE, armorType) --revert changes made to the damage instance
      end
      if defenseType ~= udg_DamageEventDefenseT then
         BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_DEFENSE_TYPE, defenseType)
      end
   end
   
   local function failsafeClear()
      --print("Damage from " .. GetUnitName(udg_DamageEventSource) .. " to " .. GetUnitName(udg_DamageEventTarget) .. " has been messing up Damage Engine.")
      --print(udg_DamageEventAmount .. " " .. " " .. udg_DamageEventPrevAmt .. " " .. udg_AttackTypeDebugStr[udg_DamageEventAttackT] .. " " .. udg_DamageTypeDebugStr[udg_DamageEventDamageT])
      resetArmor()
      canKick = true
      totem = false
      udg_DamageEventAmount = 0.00
      udg_DamageScalingWC3  = 0.00
      if udg_DamageEventDamageT ~= udg_DAMAGE_TYPE_UNKNOWN then
         runTrigs(event.damage) --Run the normal on-damage event based on this failure.
         eventsRun = true --Run the normal after-damage event based on this failure.
      end
      finish()
   end
   
   local function calibrateMR()
      udg_IsDamageMelee         = false
      udg_IsDamageRanged        = false
      udg_IsDamageSpell         = udg_DamageEventAttackT == 0 --In Patch 1.31, one can just check the attack type to find out if it's a spell.
      if udg_DamageEventDamageT == udg_DAMAGE_TYPE_NORMAL and not udg_IsDamageSpell then --This damage type is the only one that can get reduced by armor.
         udg_IsDamageMelee      = IsUnitType(udg_DamageEventSource, UNIT_TYPE_MELEE_ATTACKER)
         udg_IsDamageRanged     = IsUnitType(udg_DamageEventSource, UNIT_TYPE_RANGED_ATTACKER)
         if udg_IsDamageMelee and udg_IsDamageRanged then
            udg_IsDamageMelee   = udg_DamageEventWeaponT > 0-- Melee units play a sound when damaging
            udg_IsDamageRanged  = not udg_IsDamageMelee    -- In the case where a unit is both ranged and melee, the ranged attack plays no sound.
         end                                       -- The Huntress has a melee sound for her ranged projectile, however it is only an issue
      end                                          --if she also had a melee attack, because by default she is only UNIT_TYPE_RANGED_ATTACKER.
   end
   
   local t1 = CreateTrigger()
   TriggerRegisterAnyUnitEventBJ(t1, EVENT_PLAYER_UNIT_DAMAGING)
   TriggerAddCondition(t1, Filter(function()
      local src = GetEventDamageSource()
      local tgt = BlzGetEventDamageTarget()
      local amt = GetEventDamage()
      local at = BlzGetEventAttackType()
      local dt = BlzGetEventDamageType()
      local wt = BlzGetEventWeaponType()
      
      --print "First damage event running"
      
      if not kicking then
         if alarmSet then
            if totem then
               if dt ~= DAMAGE_TYPE_SPIRIT_LINK and dt ~= DAMAGE_TYPE_DEFENSIVE and dt ~= DAMAGE_TYPE_PLANT then
                  -- if 'totem' is still set and it's not due to spirit link distribution or defense retaliation,
                  -- the next function must be called as a debug. This reverts an issue I created in patch 5.1.3.
                  failsafeClear()
               else
                  totem       = false
                  canKick     = false
                  prev.type   = udg_DamageEventType      -- also store the damage type.
                  prev.amount = udg_DamageEventAmount
                  prev.preAmt = udg_DamageEventPrevAmt   -- Store the actual pre-armor value.
                  prev.pierce = udg_DamageEventArmorPierced
                  prev.armor  = udg_DamageEventArmorT
                  prev.preArm = armorType
                  prev.defense= udg_DamageEventDefenseT
                  prev.preDef = defenseType
                  prev.code   = udg_IsDamageCode        -- store this as well.
               end
            end
            if src ~= udg_AOEDamageSource then -- Source has damaged more than once
               onAOEEnd() -- New damage source - unflag everything
               udg_AOEDamageSource = src
            elseif tgt == udg_EnhancedDamageTarget then
               udg_DamageEventLevel= udg_DamageEventLevel + 1  -- The number of times the same unit was hit.
            elseif not IsUnitInGroup(tgt, udg_DamageEventAOEGroup) then
               udg_DamageEventAOE  = udg_DamageEventAOE + 1   -- Multiple targets hit by this source - flag as AOE
            end
         else
            TimerStart(alarm, 0.00, false, function()
               alarmSet = false --The timer has expired. Flag off to allow it to be restarted when needed.
               finish() --Wrap up any outstanding damage instance
               onAOEEnd() --Reset things so they don't perpetuate for AoE/Level target detection
            end)
            alarmSet                = true
            udg_AOEDamageSource     = src
            udg_EnhancedDamageTarget= tgt
         end
         GroupAddUnit(udg_DamageEventAOEGroup, tgt)
      end
      udg_DamageEventType           = udg_NextDamageType
      udg_IsDamageCode              = udg_NextDamageType ~= 0
      udg_DamageEventOverride       = dt == nil -- Got rid of NextDamageOverride in 5.1 for simplicity
      udg_DamageEventPrevAmt        = amt
      udg_DamageEventSource         = src
      udg_DamageEventTarget         = tgt
      udg_DamageEventAmount         = amt
      udg_DamageEventAttackT        = GetHandleId(at)
      udg_DamageEventDamageT        = GetHandleId(dt)
      udg_DamageEventWeaponT        = GetHandleId(wt)
      
      calibrateMR() -- Set Melee and Ranged settings.
      
      udg_DamageEventArmorT         = BlzGetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_ARMOR_TYPE) -- Introduced in Damage Engine 5.2.0.0
      udg_DamageEventDefenseT       = BlzGetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_DEFENSE_TYPE)
      armorType                     = udg_DamageEventArmorT
      defenseType                   = udg_DamageEventDefenseT
      udg_DamageEventArmorPierced   = 0.00
      udg_DamageScalingUser         = 1.00
      udg_DamageScalingWC3          = 1.00
      
      if amt ~= 0.00 then
         if not udg_DamageEventOverride then
            runTrigs(event.mod)
       
            -- All events have run and the pre-damage amount is finalized.
            BlzSetEventAttackType(ConvertAttackType(udg_DamageEventAttackT))
            BlzSetEventDamageType(ConvertDamageType(udg_DamageEventDamageT))
            BlzSetEventWeaponType(ConvertWeaponType(udg_DamageEventWeaponT))
            if udg_DamageEventArmorPierced ~= 0.00 then
               BlzSetUnitArmor(udg_DamageEventTarget, BlzGetUnitArmor(udg_DamageEventTarget) - udg_DamageEventArmorPierced)
            end
            if armorType ~= udg_DamageEventArmorT then
               BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_ARMOR_TYPE, udg_DamageEventArmorT) -- Introduced in Damage Engine 5.2.0.0
            end
            if defenseType ~= udg_DamageEventDefenseT then
               BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_DEFENSE_TYPE, udg_DamageEventDefenseT) -- Introduced in Damage Engine 5.2.0.0
            end
            BlzSetEventDamage(udg_DamageEventAmount)
         end
         totem = true
         -- print("Ready to deal " .. udg_DamageEventAmount)
      else
         runTrigs(event.zero)
         canKick = true
         finish()
      end
      return false
   end))
   
   local t2 = CreateTrigger()
   TriggerRegisterAnyUnitEventBJ(t2, EVENT_PLAYER_UNIT_DAMAGED)
   TriggerAddCondition(t2, Filter(function()
      if udg_DamageEventPrevAmt == 0.00 then
         return false
      end
      --print "Second event running"
      if totem then
         totem = false   --This should be the case in almost all circumstances
      else
         afterDamage() --Wrap up the outstanding damage instance
         canKick                = true
         --Unfortunately, Spirit Link and Thorns Aura/Spiked Carapace fire the DAMAGED event out of sequence with the DAMAGING event,
         --so I have to re-generate a buncha stuff here.
         udg_DamageEventSource      = GetEventDamageSource()
         udg_DamageEventTarget      = GetTriggerUnit()
         udg_DamageEventAmount      = prev.amount
         udg_DamageEventPrevAmt     = prev.preAmt
         udg_DamageEventAttackT     = GetHandleId(BlzGetEventAttackType())
         udg_DamageEventDamageT     = GetHandleId(BlzGetEventDamageType())
         udg_DamageEventWeaponT     = GetHandleId(BlzGetEventWeaponType())
         udg_DamageEventType        = prev.type
         udg_IsDamageCode           = prev.code
         udg_DamageEventArmorT      = prev.armor
         udg_DamageEventDefenseT    = prev.defense
         udg_DamageEventArmorPierced= prev.pierce
         armorType                  = prev.preArm
         defenseType                = prev.preDef
         calibrateMR() --Apply melee/ranged settings once again.
      end
      resetArmor()
      local r = GetEventDamage()
      if udg_DamageEventAmount ~= 0.00 and r ~= 0.00 then
         udg_DamageScalingWC3 = r/udg_DamageEventAmount
      else
         if udg_DamageEventAmount > 0.00 then
            udg_DamageScalingWC3 = 0.00
         else
            udg_DamageScalingWC3 = 1.00
         end
         udg_DamageScalingUser = udg_DamageEventAmount/udg_DamageEventPrevAmt
      end
      udg_DamageEventAmount = udg_DamageEventAmount*udg_DamageScalingWC3
      
      if udg_DamageEventAmount > 0.00 then
         --This event is used for custom shields which have a limited hit point value
         --The shield here kicks in after armor, so it acts like extra hit points.
         runTrigs(event.shield)
         udg_LethalDamageHP = GetWidgetLife(udg_DamageEventTarget) - udg_DamageEventAmount
         if udg_LethalDamageHP <= 0.405 then
            runTrigs(event.lethal) -- added 10 May 2019 to detect and potentially prevent lethal damage. Instead of
            -- modifying the damage, you need to modify LethalDamageHP instead (the final HP of the unit).
            
            udg_DamageEventAmount = GetWidgetLife(udg_DamageEventTarget) - udg_LethalDamageHP
            if udg_DamageEventType < 0 and udg_LethalDamageHP <= 0.405 then
               SetUnitExploded(udg_DamageEventTarget, true)   --Explosive damage types should blow up the target.
            end
         end
         udg_DamageScalingUser = udg_DamageEventAmount/udg_DamageEventPrevAmt/udg_DamageScalingWC3
      end
      BlzSetEventDamage(udg_DamageEventAmount)   --Apply the final damage amount.
      if udg_DamageEventDamageT ~= udg_DAMAGE_TYPE_UNKNOWN then
         runTrigs(event.damage)
      end
      eventsRun = true
      --print(canKick)
      if udg_DamageEventAmount == 0.00 then
         finish()
      end
      return false
   end))
   
   onGlobalInit(function()
      local i
      for i = 0, 6 do udg_CONVERTED_ATTACK_TYPE[i] = ConvertAttackType(i) end
      for i = 0, 26 do udg_CONVERTED_DAMAGE_TYPE[i] = ConvertDamageType(i) end
      
      udg_AttackTypeDebugStr[0] = "SPELLS"   -- ATTACK_TYPE_NORMAL in JASS
      udg_AttackTypeDebugStr[1] = "NORMAL"   -- ATTACK_TYPE_MELEE in JASS
      udg_AttackTypeDebugStr[2] = "PIERCE"
      udg_AttackTypeDebugStr[3] = "SIEGE"
      udg_AttackTypeDebugStr[4] = "MAGIC"
      udg_AttackTypeDebugStr[5] = "CHAOS"
      udg_AttackTypeDebugStr[6] = "HERO"
      
      udg_DamageTypeDebugStr[0]  = "UNKNOWN"
      udg_DamageTypeDebugStr[4]  = "NORMAL"
      udg_DamageTypeDebugStr[5]  = "ENHANCED"
      udg_DamageTypeDebugStr[8]  = "FIRE"
      udg_DamageTypeDebugStr[9]  = "COLD"
      udg_DamageTypeDebugStr[10] = "LIGHTNING"
      udg_DamageTypeDebugStr[11] = "POISON"
      udg_DamageTypeDebugStr[12] = "DISEASE"
      udg_DamageTypeDebugStr[13] = "DIVINE"
      udg_DamageTypeDebugStr[14] = "MAGIC"
      udg_DamageTypeDebugStr[15] = "SONIC"
      udg_DamageTypeDebugStr[16] = "ACID"
      udg_DamageTypeDebugStr[17] = "FORCE"
      udg_DamageTypeDebugStr[18] = "DEATH"
      udg_DamageTypeDebugStr[19] = "MIND"
      udg_DamageTypeDebugStr[20] = "PLANT"
      udg_DamageTypeDebugStr[21] = "DEFENSIVE"
      udg_DamageTypeDebugStr[22] = "DEMOLITION"
      udg_DamageTypeDebugStr[23] = "SLOW_POISON"
      udg_DamageTypeDebugStr[24] = "SPIRIT_LINK"
      udg_DamageTypeDebugStr[25] = "SHADOW_STRIKE"
      udg_DamageTypeDebugStr[26] = "UNIVERSAL"
      
      udg_WeaponTypeDebugStr[0]  = "NONE"    -- WEAPON_TYPE_WHOKNOWS in JASS
      udg_WeaponTypeDebugStr[1]  = "METAL_LIGHT_CHOP"
      udg_WeaponTypeDebugStr[2]  = "METAL_MEDIUM_CHOP"
      udg_WeaponTypeDebugStr[3]  = "METAL_HEAVY_CHOP"
      udg_WeaponTypeDebugStr[4]  = "METAL_LIGHT_SLICE"
      udg_WeaponTypeDebugStr[5]  = "METAL_MEDIUM_SLICE"
      udg_WeaponTypeDebugStr[6]  = "METAL_HEAVY_SLICE"
      udg_WeaponTypeDebugStr[7]  = "METAL_MEDIUM_BASH"
      udg_WeaponTypeDebugStr[8]  = "METAL_HEAVY_BASH"
      udg_WeaponTypeDebugStr[9]  = "METAL_MEDIUM_STAB"
      udg_WeaponTypeDebugStr[10] = "METAL_HEAVY_STAB"
      udg_WeaponTypeDebugStr[11] = "WOOD_LIGHT_SLICE"
      udg_WeaponTypeDebugStr[12] = "WOOD_MEDIUM_SLICE"
      udg_WeaponTypeDebugStr[13] = "WOOD_HEAVY_SLICE"
      udg_WeaponTypeDebugStr[14] = "WOOD_LIGHT_BASH"
      udg_WeaponTypeDebugStr[15] = "WOOD_MEDIUM_BASH"
      udg_WeaponTypeDebugStr[16] = "WOOD_HEAVY_BASH"
      udg_WeaponTypeDebugStr[17] = "WOOD_LIGHT_STAB"
      udg_WeaponTypeDebugStr[18] = "WOOD_MEDIUM_STAB"
      udg_WeaponTypeDebugStr[19] = "CLAW_LIGHT_SLICE"
      udg_WeaponTypeDebugStr[20] = "CLAW_MEDIUM_SLICE"
      udg_WeaponTypeDebugStr[21] = "CLAW_HEAVY_SLICE"
      udg_WeaponTypeDebugStr[22] = "AXE_MEDIUM_CHOP"
      udg_WeaponTypeDebugStr[23] = "ROCK_HEAVY_BASH"
      
      udg_DefenseTypeDebugStr[0] = "LIGHT"
      udg_DefenseTypeDebugStr[1] = "MEDIUM"
      udg_DefenseTypeDebugStr[2] = "HEAVY"
      udg_DefenseTypeDebugStr[3] = "FORTIFIED"
      udg_DefenseTypeDebugStr[4] = "NORMAL"
      udg_DefenseTypeDebugStr[5] = "HERO"
      udg_DefenseTypeDebugStr[6] = "DIVINE"
      udg_DefenseTypeDebugStr[7] = "UNARMORED"
      
      udg_ArmorTypeDebugStr[0] = "NONE"
      udg_ArmorTypeDebugStr[1] = "FLESH"
      udg_ArmorTypeDebugStr[2] = "METAL"
      udg_ArmorTypeDebugStr[3] = "WOOD"
      udg_ArmorTypeDebugStr[4] = "ETHEREAL"
      udg_ArmorTypeDebugStr[5] = "STONE"
   end)
   
   function DamageEngine_SetupEvent(whichTrig, var, val)
      --print("Setup event: " .. var)
      local mx = 1
      local off = 0
      local ex = 0
      if var == "udg_DamageModifierEvent" then --event.mod 1-4 -> Events 1-4
         if (val < 3) then 
            ex = val + 1
         end
         mx = 4
      elseif var == "udg_DamageEvent" then --event.damage 1,2 -> Events 5,6
         mx = 2
         off = 4
      elseif var == "udg_AfterDamageEvent" then --event.after -> Event 7
         off = 6
      elseif var == "udg_LethalDamageEvent" then --event.lethal -> Event 8
         off = 7
      elseif var == "udg_AOEDamageEvent" then --event.aoe -> Event 9
         off = 8
      else
         return false
      end
      local i
      if userTrigs == 9 then
         nextTrig[1] = 2
         nextTrig[2] = 3
         trigFrozen[2] = true
         trigFrozen[3] = true
         for i = 3, 9 do nextTrig[i] = 0 end
      end
      i = math.max(math.min(val, mx), 1) + off
      --print("Root index: " .. i .. " nextTrig: " .. nextTrig[i] .. " exit: " .. ex)
      repeat
         val = i
         i = nextTrig[i]
      until (i == ex)
      userTrigs = userTrigs + 1   --User list runs from index 10 and up
      nextTrig[val] = userTrigs
      nextTrig[userTrigs] = ex
      userTrig[userTrigs] = whichTrig
      levelsDeep[userTrigs] = 0
      trigFrozen[userTrigs] = false
      inceptionTrig[userTrigs] = false
      --print("Registered " .. userTrigs .. " to " .. val)
      return true
   end
   
   onRegisterVar(function(trig, var, val) 
      DamageEngine_SetupEvent(trig, var, math.floor(val))
   end)
end

--[[
TasButtonList7a by Tasyen

function CreateTasButtonList(buttonCount, parent, buttonAction, updateAction, searchAction, filterAction)
 create a new List
 parent is the container of this Frame it will attach itself to its TOP.
 buttonAction is the function that executes when an option is clicked. args: (clickedData, buttonListObject, dataIndex)
 when your data are unit-RawCodes then you can skip updateAction & searchAction.
 updateAction runs for each Button and is used to set the diplayed content. args:(frameObject, data)
    frameObject.Button
    frameObject.ToolTipFrame
    frameObject.ToolTipFrameIcon
    frameObject.ToolTipFrameName
    frameObject.ToolTipFrameSeperator
    frameObject.ToolTipFrameText

    frameObject.Icon
    frameObject.Text
    frameObject.IconGold
    frameObject.TextGold
    frameObject.IconLumber
    frameObject.TextLumber
    TasButtonList[frameObject] => buttonListObject

    data is one entry of the TasButtonLists Data-Array.

 searchAction is a function that returns true if the current data matches the searchText. Args: (data, searchedText, buttonListObject)
 filterAction is meant to be used when one wants an addtional non text based filtering, with returning true allowing data or false rejecting it. Args: (data, buttonListObject, isTextSearching)
 searchAction , udateAction & filterAction are async this functions should not do anything that alters the game state/flow.

function CreateTasButtonListV2(rowCount, parent, buttonAction, updateAction, searchAction, filterAction)
    2 Buttons each Row, takes more Height then the other Versions
function CreateTasButtonListV3(rowCount, parent, buttonAction, updateAction, searchAction, filterAction)
    3 Buttons each Row, only Icon, and Costs

function TasButtonListClearData(buttonListObject)
    remove all data
function TasButtonListRemoveData(buttonListObject, data)
    search for data and remove it
function TasButtonListAddData(buttonListObject, data)
    add data for one Button
function TasButtonListCopyData(writeObject, readObject)
    writeObject uses the same data as readObject and calls UpdateButtonList.
function UpdateTasButtonList(buttonListObject)
    update the displayed Content should be done after Data was added or removed was used.
TasButtonListSearch(buttonListObject[, text])
    The buttonList will search it's data for the given text, if nil is given as text it will search for what the user currently has in its box.
    This will also update the buttonList
--]]

BlzLoadTOCFile("war3mapimported\\TasButtonList.toc")
TasButtonList = {}

TasButtonList.SyncTrigger = CreateTrigger()
TasButtonList.SyncTriggerAction = TriggerAddAction(TasButtonList.SyncTrigger, function()
    xpcall(function()
    local buttonListObject = TasButtonList[BlzGetTriggerFrame()]
    local dataIndex = math.tointeger(BlzGetTriggerFrameValue())

    if buttonListObject.ButtonAction then
        -- call the wanted action, 1 the current Data
        buttonListObject.ButtonAction(buttonListObject.Data[dataIndex], buttonListObject, dataIndex)
    end
    UpdateTasButtonList(buttonListObject)
    end,print)
end)

-- handles the clicking
TasButtonList.ButtonTrigger = CreateTrigger()
TasButtonList.ButtonTriggerAction = TriggerAddAction(TasButtonList.ButtonTrigger, function()
    local buttonIndex = TasButtonList[BlzGetTriggerFrame()].Index
    local buttonListObject = TasButtonList[TasButtonList[BlzGetTriggerFrame()]]
    local dataIndex = buttonListObject.DataFiltered[buttonListObject.ViewPoint + buttonIndex]
    BlzFrameSetEnable(BlzGetTriggerFrame(), false)
    BlzFrameSetEnable(BlzGetTriggerFrame(), true)
    if GetLocalPlayer() == GetTriggerPlayer() then
        BlzFrameSetValue(buttonListObject.SyncFrame, dataIndex)
    end
end)

TasButtonList.SearchTrigger = CreateTrigger()
TasButtonList.SearchTriggerAction = TriggerAddAction(TasButtonList.SearchTrigger, function()
    TasButtonListSearch(TasButtonList[BlzGetTriggerFrame()], BlzFrameGetText(BlzGetTriggerFrame()))
end)

-- scrolling while pointing on Buttons
TasButtonList.ButtonScrollTrigger = CreateTrigger()
TasButtonList.ButtonScrollTriggerAction = TriggerAddAction(TasButtonList.ButtonScrollTrigger, function()
    local buttonListObject = TasButtonList[TasButtonList[BlzGetTriggerFrame()]]
    local frame = buttonListObject.Slider
    if GetLocalPlayer() == GetTriggerPlayer() then
        if BlzGetTriggerFrameValue() > 0 then
            BlzFrameSetValue(frame, BlzFrameGetValue(frame) + buttonListObject.SliderStep)
        else
            BlzFrameSetValue(frame, BlzFrameGetValue(frame) - buttonListObject.SliderStep)
        end
    end
end)

-- scrolling while pointing on slider aswell as calling
TasButtonList.SliderTrigger = CreateTrigger()
TasButtonList.SliderTriggerAction = TriggerAddAction(TasButtonList.SliderTrigger, function()
    local buttonListObject = TasButtonList[BlzGetTriggerFrame()]
    local frame = BlzGetTriggerFrame()
    if GetLocalPlayer() == GetTriggerPlayer() then
        if BlzGetTriggerFrameEvent() == FRAMEEVENT_MOUSE_WHEEL then
            if BlzGetTriggerFrameValue() > 0 then
                BlzFrameSetValue(frame, BlzFrameGetValue(frame) + buttonListObject.SliderStep)
            else
                BlzFrameSetValue(frame, BlzFrameGetValue(frame) - buttonListObject.SliderStep)
            end
        else
            -- when there is enough data use viewPoint. the Viewpoint is reduced from the data to make top being top.
            if #buttonListObject.DataFiltered > #buttonListObject.Frames then
                buttonListObject.ViewPoint = #buttonListObject.DataFiltered - math.tointeger(BlzGetTriggerFrameValue())
            else
                buttonListObject.ViewPoint = 0
            end
            UpdateTasButtonList(buttonListObject)
        end
    end
end)

--runs once for each button shown
function UpdateTasButtonListDefaultObject(frameObject, data)
    BlzFrameSetTexture(frameObject.Icon, BlzGetAbilityIcon(data), 0, false)
    BlzFrameSetText(frameObject.Text, GetObjectName(data))

    BlzFrameSetTexture(frameObject.ToolTipFrameIcon, BlzGetAbilityIcon(data), 0, false)
    BlzFrameSetText(frameObject.ToolTipFrameName, GetObjectName(data))      
--        frameObject.ToolTipFrameSeperator
    BlzFrameSetText(frameObject.ToolTipFrameText, BlzGetAbilityExtendedTooltip(data, 0))

    if not IsUnitIdType(data, UNIT_TYPE_HERO) then
        local lumber = GetUnitWoodCost(data)
        local gold = GetUnitGoldCost(data)
        if GetPlayerState(GetLocalPlayer(), PLAYER_STATE_RESOURCE_GOLD) >= gold then
            BlzFrameSetText(frameObject.TextGold, GetUnitGoldCost(data))
        else
            BlzFrameSetText(frameObject.TextGold, "|cffff2010"..GetUnitGoldCost(data))
        end    
        
        if GetPlayerState(GetLocalPlayer(), PLAYER_STATE_RESOURCE_LUMBER) >= lumber then
            BlzFrameSetText(frameObject.TextLumber, GetUnitWoodCost(data))
        else
            BlzFrameSetText(frameObject.TextLumber, "|cffff2010"..GetUnitWoodCost(data))
        end
    else
        BlzFrameSetText(frameObject.TextLumber, 0)
        BlzFrameSetText(frameObject.TextGold, 0)
    end
end

function SearchTasButtonListDefaultObject(data, searchedText, buttonListObject)
    --return BlzGetAbilityTooltip(data, 0)
    --return GetObjectName(data, 0)
    return string.find(GetObjectName(data), searchedText)
end

-- update the shown content
function UpdateTasButtonList(buttonListObject)
    xpcall(function()
    local data = buttonListObject.Data
    BlzFrameSetVisible(buttonListObject.Slider, #buttonListObject.DataFiltered > #buttonListObject.Frames)
    for int = 1, #buttonListObject.Frames do
        local frameObject = buttonListObject.Frames[int]
        if #buttonListObject.DataFiltered >= int  then
            buttonListObject.UpdateAction(frameObject, data[buttonListObject.DataFiltered[int + buttonListObject.ViewPoint]])
            BlzFrameSetVisible(frameObject.Button, true)
        else
            BlzFrameSetVisible(frameObject.Button, false)
        end
    end
end, print)
end

function InitTasButtonListObject(parent, buttonAction, updateAction, searchAction, filterAction)
    local object = {
        Data = {}, --an array each slot is the user data
        DataFiltered = {}, -- indexes of Data fitting the current search
        ViewPoint = 0,
        Frames = {},
        Parent = parent
    }
    object.ButtonAction = buttonAction --call this inside the SyncAction after a button is clicked
    object.UpdateAction = updateAction --function defining how to display stuff (async)
    object.SearchAction = searchAction --function to return the searched Text (async)
    object.FilterAction = filterAction --
    if not updateAction then object.UpdateAction = UpdateTasButtonListDefaultObject end
    if not searchAction then object.SearchAction = SearchTasButtonListDefaultObject end
    table.insert(TasButtonList, object) --index to TasButtonList
    TasButtonList[object] = #TasButtonList -- TasButtonList to Index

    object.SyncFrame = BlzCreateFrameByType("SLIDER", "", parent, "", 0)
    BlzFrameSetMinMaxValue(object.SyncFrame, 0, 9999999)
    BlzFrameSetStepSize(object.SyncFrame, 1.0)
    BlzTriggerRegisterFrameEvent(TasButtonList.SyncTrigger, object.SyncFrame, FRAMEEVENT_SLIDER_VALUE_CHANGED)
    BlzFrameSetVisible(object.SyncFrame, false)
    TasButtonList[object.SyncFrame] = object

    object.InputFrame = BlzCreateFrame("TasEditBox", parent, 0, 0)
    BlzTriggerRegisterFrameEvent(TasButtonList.SearchTrigger, object.InputFrame, FRAMEEVENT_EDITBOX_TEXT_CHANGED)
    BlzFrameSetPoint(object.InputFrame, FRAMEPOINT_TOPRIGHT, parent, FRAMEPOINT_TOPRIGHT, 0, 0)
    TasButtonList[object.InputFrame] = object

    return object
end

function InitTasButtonListSlider(object, stepSize, rowCount)
    object.Slider = BlzCreateFrameByType("SLIDER", "FrameListSlider", object.Parent, "QuestMainListScrollBar", 0)
    TasButtonList[object.Slider] = object -- the slider nows the TasButtonListobject
    object.SliderStep = stepSize
    BlzFrameSetStepSize(object.Slider, stepSize)
    BlzFrameClearAllPoints(object.Slider)
    BlzFrameSetVisible(object.Slider, true)
    BlzFrameSetMinMaxValue(object.Slider, 0, 0)
    BlzFrameSetPoint(object.Slider, FRAMEPOINT_TOPLEFT, object.Frames[1].Button, FRAMEPOINT_TOPRIGHT, 0, 0)
    BlzFrameSetSize(object.Slider, 0.012, BlzFrameGetHeight(object.Frames[1].Button) * rowCount)
    BlzTriggerRegisterFrameEvent(TasButtonList.SliderTrigger, object.Slider , FRAMEEVENT_SLIDER_VALUE_CHANGED)
    BlzTriggerRegisterFrameEvent(TasButtonList.SliderTrigger, object.Slider , FRAMEEVENT_MOUSE_WHEEL)
end

function CreateTasButtonList(buttonCount, parent, buttonAction, updateAction, searchAction, filterAction)
    local object = InitTasButtonListObject(parent, buttonAction, updateAction, searchAction, filterAction)  

    for int = 1, buttonCount do
        local frameObject = {}
        frameObject.Index = int
        frameObject.Button = BlzCreateFrame("TasButton", parent, 0, 0)
        frameObject.ToolTipFrame = BlzCreateFrame("TasButtonListTooltipBox", frameObject.Button, 0, 0)
        frameObject.ToolTipFrameIcon = BlzGetFrameByName("TasButtonListTooltipIcon", 0)
        frameObject.ToolTipFrameName = BlzGetFrameByName("TasButtonListTooltipName", 0)
        frameObject.ToolTipFrameSeperator = BlzGetFrameByName("TasButtonListTooltipSeperator", 0)
        frameObject.ToolTipFrameText = BlzGetFrameByName("TasButtonListTooltipText", 0)    
        BlzFrameSetPoint(frameObject.ToolTipFrame, FRAMEPOINT_TOPRIGHT, parent, FRAMEPOINT_TOPLEFT, -0.001, 0)
        BlzFrameSetTooltip(frameObject.Button, frameObject.ToolTipFrame)

        frameObject.Icon = BlzGetFrameByName("TasButtonIcon", 0)
        frameObject.Text = BlzGetFrameByName("TasButtonText", 0)
        frameObject.IconGold = BlzGetFrameByName("TasButtonIconGold", 0)
        frameObject.TextGold = BlzGetFrameByName("TasButtonTextGold", 0)
        frameObject.IconLumber = BlzGetFrameByName("TasButtonIconLumber", 0)
        frameObject.TextLumber = BlzGetFrameByName("TasButtonTextLumber", 0)
        TasButtonList[frameObject.Button] = frameObject
        TasButtonList[frameObject] = object
        table.insert(object.Frames, frameObject)
        BlzTriggerRegisterFrameEvent(TasButtonList.ButtonTrigger, frameObject.Button, FRAMEEVENT_CONTROL_CLICK)
        BlzTriggerRegisterFrameEvent(TasButtonList.ButtonScrollTrigger, frameObject.Button, FRAMEEVENT_MOUSE_WHEEL)
        if int > 1 then 
           BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_TOP, object.Frames[int - 1].Button, FRAMEPOINT_BOTTOM, 0, -0)
        else
            BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_TOPRIGHT, object.InputFrame, FRAMEPOINT_BOTTOMRIGHT, 0, 0)
        end
    end
    InitTasButtonListSlider(object, 1, buttonCount)

    return object
end

function CreateTasButtonListV2(rowCount, parent, buttonAction, updateAction, searchAction, filterAction)
    local buttonCount = rowCount*2
    local object = InitTasButtonListObject(parent, buttonAction, updateAction, searchAction, filterAction)

    local rowEnd = false
    for int = 1, buttonCount do
        local frameObject = {}
        frameObject.Index = int
        frameObject.Button = BlzCreateFrame("TasButtonSmall", parent, 0, 0)
        frameObject.ToolTipFrame = BlzCreateFrame("TasButtonListTooltipBox", frameObject.Button, 0, 0)
        frameObject.ToolTipFrameIcon = BlzGetFrameByName("TasButtonListTooltipIcon", 0)
        frameObject.ToolTipFrameName = BlzGetFrameByName("TasButtonListTooltipName", 0)
        frameObject.ToolTipFrameSeperator = BlzGetFrameByName("TasButtonListTooltipSeperator", 0)
        frameObject.ToolTipFrameText = BlzGetFrameByName("TasButtonListTooltipText", 0)    
        BlzFrameSetPoint(frameObject.ToolTipFrame, FRAMEPOINT_TOPRIGHT, parent, FRAMEPOINT_TOPLEFT, -0.001, 0)
        BlzFrameSetTooltip(frameObject.Button, frameObject.ToolTipFrame)

        frameObject.Icon = BlzGetFrameByName("TasButtonSmallIcon", 0)
        frameObject.Text = BlzGetFrameByName("TasButtonSmallText", 0)
        frameObject.IconGold = BlzGetFrameByName("TasButtonSmallIconGold", 0)
        frameObject.TextGold = BlzGetFrameByName("TasButtonSmallTextGold", 0)
        frameObject.IconLumber = BlzGetFrameByName("TasButtonSmallIconLumber", 0)
        frameObject.TextLumber = BlzGetFrameByName("TasButtonSmallTextLumber", 0)
        TasButtonList[frameObject.Button] = frameObject
        TasButtonList[frameObject] = object
        table.insert(object.Frames, frameObject)
        BlzTriggerRegisterFrameEvent(TasButtonList.ButtonTrigger, frameObject.Button, FRAMEEVENT_CONTROL_CLICK)
        BlzTriggerRegisterFrameEvent(TasButtonList.ButtonScrollTrigger, frameObject.Button, FRAMEEVENT_MOUSE_WHEEL)
        rowEnd = not rowEnd
        if int > 1 then 
            if rowEnd then
                BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_TOP, object.Frames[int - 2].Button, FRAMEPOINT_BOTTOM, 0, -0)
            else
                BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_RIGHT, object.Frames[int - 1].Button, FRAMEPOINT_LEFT, 0, -0)
            end
        else
            BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_TOPRIGHT, object.InputFrame, FRAMEPOINT_BOTTOMRIGHT, 0, 0)            
        end
        
    end
    InitTasButtonListSlider(object, 2, rowCount)

    return object
end

function CreateTasButtonListV3(rowCount, parent, buttonAction, updateAction, searchAction, filterAction)
    local buttonCount = rowCount*3
    local object = InitTasButtonListObject(parent, buttonAction, updateAction, searchAction, filterAction)

    local rowRemain = 3
    for int = 1, buttonCount do
        local frameObject = {}
        frameObject.Index = int
        frameObject.Button = BlzCreateFrame("TasButtonGrid", parent, 0, 0)
        frameObject.ToolTipFrame = BlzCreateFrame("TasButtonListTooltipBox", frameObject.Button, 0, 0)
        frameObject.ToolTipFrameIcon = BlzGetFrameByName("TasButtonListTooltipIcon", 0)
        frameObject.ToolTipFrameName = BlzGetFrameByName("TasButtonListTooltipName", 0)
        frameObject.ToolTipFrameSeperator = BlzGetFrameByName("TasButtonListTooltipSeperator", 0)
        frameObject.ToolTipFrameText = BlzGetFrameByName("TasButtonListTooltipText", 0)    
        BlzFrameSetPoint(frameObject.ToolTipFrame, FRAMEPOINT_TOPRIGHT, parent, FRAMEPOINT_TOPLEFT, -0.001, 0)
        BlzFrameSetTooltip(frameObject.Button, frameObject.ToolTipFrame)

        frameObject.Icon = BlzGetFrameByName("TasButtonGridIcon", 0)
        frameObject.Text = BlzGetFrameByName("TasButtonGridText", 0)
        frameObject.IconGold = BlzGetFrameByName("TasButtonGridIconGold", 0)
        frameObject.TextGold = BlzGetFrameByName("TasButtonGridTextGold", 0)
        frameObject.IconLumber = BlzGetFrameByName("TasButtonGridIconLumber", 0)
        frameObject.TextLumber = BlzGetFrameByName("TasButtonGridTextLumber", 0)
        TasButtonList[frameObject.Button] = frameObject
        TasButtonList[frameObject] = object
        table.insert(object.Frames, frameObject)
        BlzTriggerRegisterFrameEvent(TasButtonList.ButtonTrigger, frameObject.Button, FRAMEEVENT_CONTROL_CLICK)
        BlzTriggerRegisterFrameEvent(TasButtonList.ButtonScrollTrigger, frameObject.Button, FRAMEEVENT_MOUSE_WHEEL)
        
        if int > 1 then 
            if rowRemain == 0 then
                BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_TOP, object.Frames[int - 3].Button, FRAMEPOINT_BOTTOM, 0, -0)
                rowRemain = 3
            else
                BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_RIGHT, object.Frames[int - 1].Button, FRAMEPOINT_LEFT, 0, -0)
            end
        else
            BlzFrameSetPoint(frameObject.Button, FRAMEPOINT_TOPRIGHT, object.InputFrame, FRAMEPOINT_BOTTOMRIGHT, 0, 0)            
        end
        rowRemain = rowRemain - 1
    end
    InitTasButtonListSlider(object, 3, rowCount)

    return object
end

function TasButtonListAddData(buttonListObject, data)
    table.insert( buttonListObject.Data, data)
    table.insert( buttonListObject.DataFiltered, #buttonListObject.Data)
    --BlzFrameSetMinMaxValue(buttonListObject.Slider, 0, #buttonListObject.Data - (#buttonListObject.Frames + 0))
    BlzFrameSetMinMaxValue(buttonListObject.Slider, #buttonListObject.Frames, #buttonListObject.Data)
end

function TasButtonListRemoveData(buttonListObject, data)
    local found = false
    for index, value in ipairs(buttonListObject.Data)
    do
        if value == data then
            table.remove(buttonListObject.Data, index)
            found = true
            break
        end
    end
    --BlzFrameSetMinMaxValue(buttonListObject.Slider, 0, #buttonListObject.Data - (#buttonListObject.Frames + 0))
    BlzFrameSetMinMaxValue(buttonListObject.Slider, #buttonListObject.Frames, #buttonListObject.Data)
end

function TasButtonListClearData(buttonListObject)
    repeat until not table.remove(buttonListObject.Data)
    repeat until not table.remove(buttonListObject.DataFiltered)
    BlzFrameSetMinMaxValue(buttonListObject.Slider, 0, 0)
end

function TasButtonListCopyData(writeObject, readObject)
    writeObject.Data = readObject.Data
    repeat until not table.remove(writeObject.DataFiltered)
    for index, value in ipairs(readObject.DataFiltered) do table.insert( writeObject.DataFiltered, value) end
    --BlzFrameSetMinMaxValue(writeObject.Slider, 0, #writeObject.Data - (#writeObject.Frames + 0))
    BlzFrameSetMinMaxValue(writeObject.Slider, #writeObject.Frames, #writeObject.Data)
    UpdateTasButtonList(writeObject)
end

function TasButtonListSearch(buttonListObject, text)
    if not text then text = BlzFrameGetText(buttonListObject.InputFrame) end
    local filteredData = buttonListObject.DataFiltered
    
    if GetLocalPlayer() == GetTriggerPlayer() then
        repeat do end until not table.remove(filteredData)
        if text ~= "" then
            for index, value in ipairs(buttonListObject.Data)
            do
                if buttonListObject.SearchAction(value, text, buttonListObject) and (not buttonListObject.FilterAction or buttonListObject.FilterAction(value, buttonListObject, true)) then
                    table.insert(filteredData, index)
                end
            end
            
        else
            for index, value in ipairs(buttonListObject.Data)
            do
                if not buttonListObject.FilterAction or buttonListObject.FilterAction(value, buttonListObject, false) then
                    table.insert(filteredData, index)
                end
            end
        end
        --table.sort(filteredData, function(a, b) return GetObjectName(buttonListObject.Data[a]) < GetObjectName(buttonListObject.Data[b]) end  )

        --update Slider, with that also update
        BlzFrameSetMinMaxValue(buttonListObject.Slider, #buttonListObject.Frames, math.max(#filteredData,0))
        BlzFrameSetValue(buttonListObject.Slider, 999999)
        
    end
end

TimerT = CreateTimer()
TimerStart(TimerT, 0.0, false, function()
    xpcall(function()
        local timer = GetExpiredTimer()
        local shopOwner = Player(bj_PLAYER_NEUTRAL_EXTRA)
        local shop = CreateUnit(shopOwner, FourCC('n003'), -3800, 6000, 0)
        local shopRect = Rect(0 , 0, 1000, 1000)
        MoveRectTo(shopRect, GetUnitX(shop), GetUnitY(shop))

        IssueNeutralTargetOrder(shopOwner, shop, "smart", shop)
        SetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_GOLD, 99999999)
        SetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_LUMBER, 99999999)   
    local triggerOrder = CreateTrigger()
    ItemData = {}
    ItemData.Test = {}
    ItemData.Counter = 0
    TriggerAddAction(triggerOrder, function()
        xpcall(function()
        local itemCode = GetIssuedOrderId()
        --print("Order", GetObjectName(itemCode) )
        if not ItemData[itemCode] then 
            ItemData[itemCode] = {
                Gold = GetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_GOLD),
                Lumber = GetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_LUMBER)
            }
            TimerStart(timer, 0, false, function()
                
                xpcall(function()
                    
                ItemData.Counter = ItemData.Counter + 1
                --print("After 0", GetObjectName(itemCode), ItemData.Counter)
                ItemData[itemCode].Gold = ItemData[itemCode].Gold - GetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_GOLD)
                ItemData[itemCode].Lumber = ItemData[itemCode].Lumber - GetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_LUMBER)
                --print(GetObjectName(itemCode), ItemData[itemCode].Gold, ItemData[itemCode].Lumber)
                UnitRemoveAbility(shop, FourCC("Asid"))
                UnitAddAbility(shop, FourCC("Asid"))
                for index, value in ipairs(ItemData.Test)
                do
                    if value == itemCode then table.remove(ItemData.Test, index) break end
                end
                if #ItemData.Test > 0 then
                    AddItemToStock(shop, ItemData.Test[1], 1, 1)
                    SetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_GOLD, 99999999)
                    SetPlayerState(shopOwner, PLAYER_STATE_RESOURCE_LUMBER, 99999999)   
                    --print("Next", GetObjectName(ItemData.Test[1]), string.pack(">I4", ItemData.Test[1]))
                    IssueNeutralImmediateOrderById(shopOwner, shop, ItemData.Test[1])
                else
                    --print("out of data", ItemData.Counter)
                end
                EnumItemsInRect(shopRect, nil, function()
                    RemoveItem(GetEnumItem())
                end)
            end, print)
            end)
        end
    end, print)
    end)
    
    TriggerRegisterUnitEvent(triggerOrder, shop, EVENT_UNIT_ISSUED_ORDER)
    

    print("done")
    function ItemGetCost(itemCode)
        if not ItemData[itemCode] then
            table.insert( ItemData.Test, itemCode)
            if #ItemData.Test == 1 then
                print("start new")
                AddItemToStock(shop, itemCode, 1, 1)
                IssueNeutralTargetOrder(shopOwner, shop, "smart", shop2)
                IssueNeutralImmediateOrderById(shopOwner, shop, itemCode)
                --IssueNeutralTargetOrderById(shopOwner, shop, itemCode, shop)
            end
        else
        end
    end
end, print)
end)

do
   local MAX_WASTED = 1 --Every MAX_WASTED units created after map initialization, run the "garbage collector"
   
   local sUUD = SetUnitUserData
   function SetUnitUserData(whichUnit, val) end -- disallow user from changing this value.
   
   local function runEvent(dex, val)
      local pdex = udg_UDex
      udg_UDex = dex
      globals.udg_UnitIndexEvent = 0.00
      globals.udg_UnitIndexEvent = val
      udg_UDex = pdex
   end
   
   local iFuncs = {}
   function onUnitIndex(func)
      iFuncs[func] = func
   end
   onUnitIndex(function(dex) runEvent(dex, 1.00) end)
   
   local dFuncs = {}
   function onUnitDeindex(func)
      dFuncs[func] = func
   end
   onUnitDeindex(function(dex) runEvent(dex, 2.00) end)
   
   local wasted = 0
   local gen = 0
   local active = {}
   local inactive = {}
   local preplaced = true
   
   onTriggerInit(function()
      local re = CreateRegion()
      local r = GetWorldBounds()
      RegionAddRect(re, r) RemoveRect(r)
      local b = Filter(function()
         u = GetFilterUnit()
         if GetUnitUserData(u) == 0 then
            local dex
            if not preplaced then -- No need to check for removed units during the beginning of the game sequence
               wasted = wasted + 1
               if wasted > MAX_WASTED then
                  local n = #active
                  for i = n, 1, -1 do
                     if GetUnitUserData(udg_UDexUnits[dex]) == 0 then
                        active[i] = active[n]
                        active[n] = nil
                        n = n - 1
                        inactive[#inactive + 1] = dex
                        for k, f in pairs(dFuncs) do f(dex) end -- Run the deindex event
                        --print("deindexed" .. dex)
                     end
                  end
                  wasted = 0
               end
            end
            local n = #inactive
            if n == 0 then
               dex = gen + 1
               gen = dex
            else
               dex = inactive[n]
               inactive[n] = nil
            end
            active[#active + 1] = dex
            
            udg_UDexUnits[dex] = u
            sUUD(udg_UDexUnits[dex], dex)
            
            udg_IsUnitPreplaced[dex] = preplaced
            for k, f in pairs(iFuncs) do f(dex) end -- Run the index event
            --print("indexed " .. dex)
         end
         return false
      end)
      TriggerRegisterEnterRegion(CreateTrigger(), re, b)
      for i = bj_MAX_PLAYER_SLOTS - 1, 0, -1 do
         GroupEnumUnitsOfPlayer(bj_lastCreatedGroup, Player(i), b)
      end
      preplaced = false
      globals.udg_UnitIndexEvent = 3.00
   end)
end
-- Arcing Text Tag v1.0.0.3 by Maker encoded to Lua

DEFINITION      = 1.0/60.0
SIZE_MIN        = 0.018         -- Minimum size of text
SIZE_BONUS      = 0.012         -- Text size increase
TIME_LIFE       = 1.0           -- How long the text lasts
TIME_FADE       = 0.8           -- When does the text start to fade
Z_OFFSET        = 50            -- Height above unit
Z_OFFSET_BON    = 50            -- How much extra height the text gains
VELOCITY        = 2.0           -- How fast the text move in x/y plane
TMR             = CreateTimer()

ANGLE_RND       = true          -- Is the angle random or fixed
if not ANGLE_RND then
    ANGLE       = bj_PI/2.0     -- If fixed, specify the Movement angle of the text.
end

tt   = {}
as   = {} -- angle, sin component
ac   = {} -- angle, cos component
ah   = {} -- arc height
t    = {} -- time
x    = {} -- origin x
y    = {} -- origin y
str  = {} -- text

ic   = 0  -- Instance count   
rn   = {} ; rn[0] = 0
next = {} ; next[0] = 0
prev = {} ; prev[0] = 0 --Needed due to Lua not initializing them.

function ArcingTextTag(s, u)
    local this = rn[0]
    if this == 0 then
        ic = ic + 1
        this = ic
    else
        rn[0] = rn[this]
    end
    
    next[this] = 0
    prev[this] = prev[0]
    next[prev[0]] = this
    prev[0] = this
    
    str[this] = s
    x[this] = GetUnitX(u)
    y[this] = GetUnitY(u)
    t[this] = TIME_LIFE
    
    local a
    if ANGLE_RND then
        a = GetRandomReal(0, 2*bj_PI)
    else
        a = ANGLE
    end
    as[this] = Sin(a)*VELOCITY
    ac[this] = Cos(a)*VELOCITY
    ah[this] = 0.
    
    if IsUnitVisible(u, GetLocalPlayer()) then
        tt[this] = CreateTextTag()
        SetTextTagPermanent(tt[this], false)
        SetTextTagLifespan(tt[this], TIME_LIFE)
        SetTextTagFadepoint(tt[this], TIME_FADE)
        SetTextTagText(tt[this], s, SIZE_MIN)
        SetTextTagPos(tt[this], x[this], y[this], Z_OFFSET)
    end
    
    if prev[this] == 0 then
        TimerStart(TMR, DEFINITION, true, function()
            local this = next[0]
            local p
            while (this ~= 0) do
                p = Sin(bj_PI*t[this])
                t[this] = t[this] - DEFINITION
                x[this] = x[this] + ac[this]
                y[this] = y[this] + as[this]
                SetTextTagPos(tt[this], x[this], y[this], Z_OFFSET + Z_OFFSET_BON * p)
                SetTextTagText(tt[this], str[this], SIZE_MIN + SIZE_BONUS * p)
                if t[this] <= 0.0 then
                    tt[this] = null
                    next[prev[this]] = next[this]
                    prev[next[this]] = prev[this]
                    rn[this] = rn[0]
                    rn[0] = this
                    if next[0] == 0 then
                        PauseTimer(TMR)
                    end
                end
                this = next[this]
            end
        end)
    end
    return this
end
do
   local data = {}
   function SetTimerData(whichTimer, dat)
      data[whichTimer] = dat
   end

   --GetData functionality doesn't even require an argument.
   function GetTimerData(whichTimer)
      if not whichTimer then whichTimer = GetExpiredTimer() end
      return data[whichTimer]
   end

   --NewTimer functionality includes optional parameter to pass data to timer.
   function NewTimer(dat)
      local t = CreateTimer()
      if dat then data[t] = dat end
      return t
   end

   --Release functionality doesn't even need for you to pass the expired timer.
   --as an arg. It also returns the user data passed.
   function ReleaseTimer(whichTimer)
      if not whichTimer then whichTimer = GetExpiredTimer() end
      local dat = data[whichTimer]
      data[whichTimer] = nil
      PauseTimer(whichTimer)
      DestroyTimer(whichTimer)
      return dat
   end
end
do
   local cMap = {}
   local aMap = {}
   local lastCondFunc
   local waitFunc
   
   local oldCond = Condition --If you don't want this Condition-overwrite behavior
   --for any particular resource, use Filter() instead of Condition(). This tool
   --is mainly for GUI users & the GUI->script compiled behavior uses Condition().
   function Condition(func)
      lastCondFunc = func
      return oldCond(func)
   end
   
   local oldTAC = TriggerAddCondition
   function TriggerAddCondition(trig, cond)
      if lastCondFunc then
         cMap[trig] = lastCondFunc --map the condition function to the trigger.
         lastCondFunc = nil
         cond = Filter(function()
            local t = GetTriggeringTrigger()
            if cMap[t]() then --Call the triggerconditions manually.
               waitFunc = aMap[t]
               waitFunc() --If this was caused by an event, call the trigger actions manually.
            end
         end)
      end
      return oldTAC(trig, cond) --use the regular event if a boolexpr or Filter
      --was used instead of Condition()
   end
   
   local oldTAA = TriggerAddAction
   function TriggerAddAction(trig, act)
      aMap[trig] = act
      return oldTAA(trig, function()
         waitFunc = aMap[GetTriggeringTrigger()]
         waitFunc() --If this was caused by an event, call the trigger actions manually.
      end)
   end
   
   local oldEval = TriggerEvaluate
   function TriggerEvaluate(trig)
      local f = cMap[trig]
      if f then return f() end
      return oldEval(trig)
   end
   
   local oldExec = TriggerExecute
   function TriggerExecute(trig)
      waitFunc = aMap[trig]
      waitFunc()
   end
   
   function RunTrigger(trig)
      local conds = cMap[trig]
      if IsTriggerEnabled(trig) and not conds or conds() then
         waitFunc = aMap[trig]
         waitFunc()
      end
   end
   
   local skipNext = false
   function EnableWaits()
      if skipNext then
         skipNext = false
         return false
      end
      skipNext = true
      coroutine.resume(coroutine.create(function()
         waitFunc()
      end))
      return true
   end
end
do
   local oldWait = PolledWait
   function PolledWait(duration)
      local thread = coroutine.running()
      if thread then
         TimerStart(NewTimer(thread), duration, false, function()
            coroutine.resume(ReleaseTimer())
         end)
         coroutine.yield(thread)
      else
         oldWait(duration)
      end
   end
   
   local oldTSA = TriggerSleepAction
   function TriggerSleepAction(duration) PolledWait(duration) end
   
   local thread
   local oldSync = SyncSelections
   function SyncSelectionsHelper()
      local t = thread
      oldSync()
      coroutine.resume(t)
   end
   function SyncSelections()
      thread = coroutine.running()
      if thread then
         ExecuteFunc("SyncSelectionsHelper")
         coroutine.yield(thread)
      else
         oldSync()
      end
   end
   
   if not EnableWaits then --Added this check to ensure compatibilitys with Lua Fast Triggers
      local oldAction = TriggerAddAction
      function TriggerAddAction(whichTrig, userAction)
         oldAction(whichTrig, function()
            coroutine.resume(coroutine.create(function()
               userAction()
            end))
         end)
      end
   end
end
function CreateBuildingsForPlayer0()
    local p = Player(0)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("h000"), 6272.0, 3200.0, 270.000, FourCC("h000"))
    u = BlzCreateUnitWithSkin(p, FourCC("h001"), 4480.0, 3584.0, 270.000, FourCC("h001"))
    u = BlzCreateUnitWithSkin(p, FourCC("h002"), 5696.0, 3840.0, 270.000, FourCC("h002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3264.0, 3072.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1792.0, 3072.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3072.0, 3712.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2304.0, 3712.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1728.0, 2304.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3392.0, 2304.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1856.0, 1472.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3264.0, 1600.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1792.0, 1024.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2944.0, 640.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3520.0, 960.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1984.0, 512.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3008.0, 960.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1920.0, 768.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2688.0, 1472.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2624.0, 1984.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2752.0, 2496.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3456.0, 3072.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1984.0, 3008.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1792.0, 3648.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("h004"), 5440.0, 2560.0, 270.000, FourCC("h004"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 896.0, 1152.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 320.0, 1984.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 384.0, 3136.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 1408.0, 3584.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 2624.0, 3456.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 1920.0, 2560.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3008.0, 1920.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 2176.0, 1344.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3584.0, 1152.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 4224.0, 1088.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5376.0, 1024.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5312.0, 1728.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 4864.0, 1792.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3584.0, 2048.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3008.0, 2816.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3520.0, 3520.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 4480.0, 3264.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5888.0, 2944.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5120.0, 2368.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3648.0, 2304.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 704.0, 3456.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 1024.0, 2624.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 7232.0, 3712.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 7168.0, 1152.0, 270.000, FourCC("n002"))
end

function CreateUnitsForPlayer0()
    local p = Player(0)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("nban"), 1522.0, 2289.8, 270.000, FourCC("nban"))
    u = BlzCreateUnitWithSkin(p, FourCC("h007"), 1358.5, 2201.4, 5.878, FourCC("h007"))
    u = BlzCreateUnitWithSkin(p, FourCC("n006"), 1681.9, 2309.3, 1.077, FourCC("n006"))
    u = BlzCreateUnitWithSkin(p, FourCC("h008"), 1247.6, 2393.5, 208.560, FourCC("h008"))
    u = BlzCreateUnitWithSkin(p, FourCC("n005"), 1461.1, 2482.9, 43.595, FourCC("n005"))
end

function CreateBuildingsForPlayer1()
    local p = Player(1)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("h000"), 5888.0, -2624.0, 270.000, FourCC("h000"))
    u = BlzCreateUnitWithSkin(p, FourCC("h001"), 4288.0, -3712.0, 270.000, FourCC("h001"))
    u = BlzCreateUnitWithSkin(p, FourCC("h002"), 5504.0, -3648.0, 270.000, FourCC("h002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3456.0, -192.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3072.0, -256.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2176.0, -320.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1664.0, -320.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1728.0, -896.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2368.0, -960.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3136.0, -960.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3456.0, -896.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1728.0, -1472.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2688.0, -1536.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3008.0, -1472.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3584.0, -1472.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3520.0, -2240.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2816.0, -2176.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2176.0, -2240.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1472.0, -2240.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2304.0, -3072.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2880.0, -3072.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3264.0, -3072.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -3328.0, -3648.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -2624.0, -3712.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), -1856.0, -3776.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 384.0, -3584.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 192.0, -2688.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 320.0, -1792.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 768.0, -960.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 1856.0, -704.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3072.0, -1024.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 4096.0, -960.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5184.0, -1024.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5888.0, -704.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 5376.0, -2112.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 4224.0, -2112.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 2944.0, -2048.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 2944.0, -3008.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 2880.0, -3584.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 3648.0, -3264.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 4672.0, -3264.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 1984.0, -1728.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 7168.0, -1088.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("n002"), 7168.0, -2880.0, 270.000, FourCC("n002"))
    u = BlzCreateUnitWithSkin(p, FourCC("h004"), 4928.0, -2560.0, 270.000, FourCC("h004"))
end

function CreateUnitsForPlayer1()
    local p = Player(1)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("h007"), 1545.1, -2263.5, 303.230, FourCC("h007"))
    u = BlzCreateUnitWithSkin(p, FourCC("nban"), 1406.6, -2246.6, 90.000, FourCC("nban"))
    u = BlzCreateUnitWithSkin(p, FourCC("n006"), 1220.0, -2341.2, 39.750, FourCC("n006"))
    u = BlzCreateUnitWithSkin(p, FourCC("h008"), 1568.5, -2428.8, 105.800, FourCC("h008"))
    u = BlzCreateUnitWithSkin(p, FourCC("n005"), 1389.4, -2414.0, 10.320, FourCC("n005"))
end

function CreateBuildingsForPlayer2()
    local p = Player(2)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("h001"), 4352.0, 896.0, 270.000, FourCC("h001"))
    u = BlzCreateUnitWithSkin(p, FourCC("h000"), 5888.0, 1536.0, 270.000, FourCC("h000"))
    u = BlzCreateUnitWithSkin(p, FourCC("h002"), 5376.0, 768.0, 270.000, FourCC("h002"))
    u = BlzCreateUnitWithSkin(p, FourCC("h004"), 5440.0, 1984.0, 270.000, FourCC("h004"))
end

function CreateBuildingsForPlayer3()
    local p = Player(3)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("h001"), 4352.0, -512.0, 270.000, FourCC("h001"))
    u = BlzCreateUnitWithSkin(p, FourCC("h000"), 6272.0, -768.0, 270.000, FourCC("h000"))
    u = BlzCreateUnitWithSkin(p, FourCC("h002"), 5376.0, -768.0, 270.000, FourCC("h002"))
    u = BlzCreateUnitWithSkin(p, FourCC("h004"), 5376.0, -1728.0, 270.000, FourCC("h004"))
end

function CreateBuildingsForPlayer6()
    local p = Player(6)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("n000"), 1504.0, 2720.0, 270.000, FourCC("n000"))
    u = BlzCreateUnitWithSkin(p, FourCC("n004"), -2624.0, 3456.0, 270.000, FourCC("n004"))
end

function CreateBuildingsForPlayer7()
    local p = Player(7)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("n000"), 1376.0, -2784.0, 270.000, FourCC("n000"))
    u = BlzCreateUnitWithSkin(p, FourCC("n004"), -2560.0, -3520.0, 270.000, FourCC("n004"))
end

function CreateNeutralPassiveBuildings()
    local p = Player(PLAYER_NEUTRAL_PASSIVE)
    local u
    local unitID
    local t
    local life
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1536.0, 3584.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 640.0, 2688.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1536.0, 1792.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2432.0, 2688.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1152.0, 3456.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 768.0, 3072.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1920.0, 3456.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2304.0, 3072.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2304.0, 2304.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1920.0, 1920.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1152.0, 1920.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 768.0, 2304.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 960.0, 3264.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 960.0, 2112.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2112.0, 2112.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2112.0, 3264.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1408.0, -1920.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 512.0, -2816.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1408.0, -3712.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2304.0, -2816.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1792.0, -2048.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2176.0, -2432.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 2176.0, -3200.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1792.0, -3584.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1024.0, -3584.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 640.0, -3200.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 640.0, -2432.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1024.0, -2048.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 832.0, -2240.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1984.0, -2240.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 1984.0, -3392.0, 270.000, FourCC("n001"))
    u = BlzCreateUnitWithSkin(p, FourCC("n001"), 832.0, -3392.0, 270.000, FourCC("n001"))
end

function CreatePlayerBuildings()
    CreateBuildingsForPlayer0()
    CreateBuildingsForPlayer1()
    CreateBuildingsForPlayer2()
    CreateBuildingsForPlayer3()
    CreateBuildingsForPlayer6()
    CreateBuildingsForPlayer7()
end

function CreatePlayerUnits()
    CreateUnitsForPlayer0()
    CreateUnitsForPlayer1()
end

function CreateAllUnits()
    CreateNeutralPassiveBuildings()
    CreatePlayerBuildings()
    CreatePlayerUnits()
end

function Trig_Damage_Engine_Config_Actions()
    udg_DamageTypePureExplosive = -2
    udg_DamageTypeExplosive = -1
    udg_DamageTypeCode = 1
    udg_DamageTypePure = 2
    udg_DamageTypeHeal = 3
    udg_DamageTypeBlocked = 4
    udg_DamageTypeReduced = 5
    udg_DamageTypeCriticalStrike = 6
    udg_DamageEventAOE = 1
    udg_DamageEventLevel = 1
    udg_ATTACK_TYPE_SPELLS = 0
    udg_ATTACK_TYPE_NORMAL = 1
    udg_ATTACK_TYPE_PIERCE = 2
    udg_ATTACK_TYPE_SIEGE = 3
    udg_ATTACK_TYPE_MAGIC = 4
    udg_ATTACK_TYPE_CHAOS = 5
    udg_ATTACK_TYPE_HERO = 6
    udg_DAMAGE_TYPE_UNKNOWN = 0
    udg_DAMAGE_TYPE_NORMAL = 4
    udg_DAMAGE_TYPE_ENHANCED = 5
    udg_DAMAGE_TYPE_FIRE = 8
    udg_DAMAGE_TYPE_COLD = 9
    udg_DAMAGE_TYPE_LIGHTNING = 10
    udg_DAMAGE_TYPE_POISON = 11
    udg_DAMAGE_TYPE_DISEASE = 12
    udg_DAMAGE_TYPE_DIVINE = 13
    udg_DAMAGE_TYPE_MAGIC = 14
    udg_DAMAGE_TYPE_SONIC = 15
    udg_DAMAGE_TYPE_ACID = 16
    udg_DAMAGE_TYPE_FORCE = 17
    udg_DAMAGE_TYPE_DEATH = 18
    udg_DAMAGE_TYPE_MIND = 19
    udg_DAMAGE_TYPE_PLANT = 20
    udg_DAMAGE_TYPE_DEFENSIVE = 21
    udg_DAMAGE_TYPE_DEMOLITION = 22
    udg_DAMAGE_TYPE_SLOW_POISON = 23
    udg_DAMAGE_TYPE_SPIRIT_LINK = 24
    udg_DAMAGE_TYPE_SHADOW_STRIKE = 25
    udg_DAMAGE_TYPE_UNIVERSAL = 26
    udg_WEAPON_TYPE_NONE = 0
    udg_WEAPON_TYPE_ML_CHOP = 1
    udg_WEAPON_TYPE_MM_CHOP = 2
    udg_WEAPON_TYPE_MH_CHOP = 3
    udg_WEAPON_TYPE_ML_SLICE = 4
    udg_WEAPON_TYPE_MM_SLICE = 5
    udg_WEAPON_TYPE_MH_SLICE = 6
    udg_WEAPON_TYPE_MM_BASH = 7
    udg_WEAPON_TYPE_MH_BASH = 8
    udg_WEAPON_TYPE_MM_STAB = 9
    udg_WEAPON_TYPE_MH_STAB = 10
    udg_WEAPON_TYPE_WL_SLICE = 11
    udg_WEAPON_TYPE_WM_SLICE = 12
    udg_WEAPON_TYPE_WH_SLICE = 13
    udg_WEAPON_TYPE_WL_BASH = 14
    udg_WEAPON_TYPE_WM_BASH = 15
    udg_WEAPON_TYPE_WH_BASH = 16
    udg_WEAPON_TYPE_WL_STAB = 17
    udg_WEAPON_TYPE_WM_STAB = 18
    udg_WEAPON_TYPE_CL_SLICE = 19
    udg_WEAPON_TYPE_CM_SLICE = 20
    udg_WEAPON_TYPE_CH_SLICE = 21
    udg_WEAPON_TYPE_AM_CHOP = 22
    udg_WEAPON_TYPE_RH_BASH = 23
    udg_ARMOR_TYPE_NONE = 0
    udg_ARMOR_TYPE_FLESH = 1
    udg_ARMOR_TYPE_METAL = 2
    udg_ARMOR_TYPE_WOOD = 3
    udg_ARMOR_TYPE_ETHEREAL = 4
    udg_ARMOR_TYPE_STONE = 5
    udg_DEFENSE_TYPE_LIGHT = 0
    udg_DEFENSE_TYPE_MEDIUM = 1
    udg_DEFENSE_TYPE_HEAVY = 2
    udg_DEFENSE_TYPE_FORTIFIED = 3
    udg_DEFENSE_TYPE_NORMAL = 4
    udg_DEFENSE_TYPE_HERO = 5
    udg_DEFENSE_TYPE_DIVINE = 6
    udg_DEFENSE_TYPE_UNARMORED = 7
end

function InitTrig_Damage_Engine_Config()
    gg_trg_Damage_Engine_Config = CreateTrigger()
    TriggerAddAction(gg_trg_Damage_Engine_Config, Trig_Damage_Engine_Config_Actions)
end

function Trig_StartResources_Func001A()
    SetPlayerStateBJ(GetEnumPlayer(), PLAYER_STATE_RESOURCE_LUMBER, 200)
    SetPlayerStateBJ(GetEnumPlayer(), PLAYER_STATE_RESOURCE_GOLD, 320)
end

function Trig_StartResources_Actions()
    ForForce(GetPlayersAll(), Trig_StartResources_Func001A)
end

function InitTrig_StartResources()
    gg_trg_StartResources = CreateTrigger()
    TriggerAddAction(gg_trg_StartResources, Trig_StartResources_Actions)
end

function Trig_Melee_Initialization_Actions()
    MeleeStartingVisibility()
    MeleeStartingHeroLimit()
end

function InitTrig_Melee_Initialization()
    gg_trg_Melee_Initialization = CreateTrigger()
    TriggerAddAction(gg_trg_Melee_Initialization, Trig_Melee_Initialization_Actions)
end

function Trig_DamageOnMovingUnit_Func002C()
    if (not (udg_UnitMoving[GetUnitUserData(udg_DamageEventTarget)] == true)) then
        return false
    end
    return true
end

function Trig_DamageOnMovingUnit_Actions()
    if (Trig_DamageOnMovingUnit_Func002C()) then
    else
    end
end

function InitTrig_DamageOnMovingUnit()
    gg_trg_DamageOnMovingUnit = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_DamageOnMovingUnit, "udg_DamageModifierEvent", EQUAL, 1.00)
    TriggerAddAction(gg_trg_DamageOnMovingUnit, Trig_DamageOnMovingUnit_Actions)
end

function Trig_DamageModifier_Actions()
end

function InitTrig_DamageModifier()
    gg_trg_DamageModifier = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_DamageModifier, "udg_DamageModifierEvent", EQUAL, 1.00)
    TriggerAddAction(gg_trg_DamageModifier, Trig_DamageModifier_Actions)
end

function Trig_Prevent_Lethal_Actions()
end

function InitTrig_Prevent_Lethal()
    gg_trg_Prevent_Lethal = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_Prevent_Lethal, "udg_LethalDamageEvent", EQUAL, 1.00)
    TriggerAddAction(gg_trg_Prevent_Lethal, Trig_Prevent_Lethal_Actions)
end

function Trig_Is_Unit_Moving_Actions()
    udg_UDex = udg_UMovNext[0]
        while (udg_UDex ~= 0) do
            udg_TempX = GetUnitX(udg_UDexUnits[udg_UDex])
            udg_TempY = GetUnitY(udg_UDexUnits[udg_UDex])
            if udg_TempX ~= udg_UnitMovingX[udg_UDex] or udg_TempY ~= udg_UnitMovingY[udg_UDex] then
    udg_UnitMovingX[udg_UDex] = udg_TempX
    udg_UnitMovingY[udg_UDex] = udg_TempY
                if not udg_UnitMoving[udg_UDex] then
                    if GetUnitTypeId(udg_UDexUnits[udg_UDex]) ~= 0 then
    udg_UnitMoving[udg_UDex] = true
    udg_UnitMovingEvent = 1.00
    udg_UnitMovingEvent = 0.00
                    elseif udg_UnitMovingInList[udg_UDex] then
    udg_UnitMovingInList[udg_UDex] = false
    udg_UnitMoving[udg_UDex] = false
    udg_UMovNext[udg_UMovPrev[udg_UDex]] = udg_UMovNext[udg_UDex]
    udg_UMovPrev[udg_UMovNext[udg_UDex]] = udg_UMovPrev[udg_UDex]
                    end
                end
            elseif udg_UnitMoving[udg_UDex] then
    udg_UnitMoving[udg_UDex] = false
    udg_UnitMovingEvent = 2.00
    udg_UnitMovingEvent = 0.00
            end
    udg_UDex = udg_UMovNext[udg_UDex]
        end
end

function InitTrig_Is_Unit_Moving()
    gg_trg_Is_Unit_Moving = CreateTrigger()
    TriggerRegisterTimerEventPeriodic(gg_trg_Is_Unit_Moving, 0.05)
    TriggerAddAction(gg_trg_Is_Unit_Moving, Trig_Is_Unit_Moving_Actions)
end

function Trig_Unit_Moving_Index_Func005C()
    if (not (GetUnitDefaultMoveSpeed(udg_UDexUnits[udg_UDex]) ~= 0.00)) then
        return false
    end
    return true
end

function Trig_Unit_Moving_Index_Actions()
    if (Trig_Unit_Moving_Index_Func005C()) then
        udg_UnitMovingInList[udg_UDex] = true
        udg_UMovPrev[udg_UMovNext[0]] = udg_UDex
        udg_UMovNext[udg_UDex] = udg_UMovNext[0]
        udg_UMovNext[0] = udg_UDex
                udg_UnitMovingX[udg_UDex] = GetUnitX(udg_UDexUnits[udg_UDex])
                udg_UnitMovingY[udg_UDex] = GetUnitY(udg_UDexUnits[udg_UDex])
    else
    end
end

function InitTrig_Unit_Moving_Index()
    gg_trg_Unit_Moving_Index = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_Unit_Moving_Index, "udg_UnitIndexEvent", EQUAL, 1.00)
    TriggerAddAction(gg_trg_Unit_Moving_Index, Trig_Unit_Moving_Index_Actions)
end

function Trig_Unit_Indexer_Event_Actions()
end

function InitTrig_Unit_Indexer_Event()
    gg_trg_Unit_Indexer_Event = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_Unit_Indexer_Event, "udg_UnitIndexEvent", EQUAL, -1.00)
    TriggerAddAction(gg_trg_Unit_Indexer_Event, Trig_Unit_Indexer_Event_Actions)
end

function Trig_Damage_Tag_Func004Func001Func001C()
    if (not (udg_DamageScalingWC3 == 0.00)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func001C()
    if (not (GetUnitTypeId(udg_DamageEventSource) == FourCC("hpea"))) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func002Func001Func001Func001Func001Func002C()
    if (not (udg_IsDamageRanged == true)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func002Func001Func001Func001Func001C()
    if (not (udg_IsDamageSpell == true)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func002Func001Func001Func001C()
    if (not (udg_DamageScalingUser < 0.60)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func002Func001Func001C()
    if (not (udg_DamageEventAmount > 0.99)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func002Func001C()
    if (not (udg_DamageScalingUser >= 1.50)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004Func002C()
    if (not (udg_DamageEventAmount < -0.99)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Func004C()
    if (not (udg_DamageEventAmount == 0.00)) then
        return false
    end
    return true
end

function Trig_Damage_Tag_Actions()
    udg_ReportLife = GetUnitStateSwap(UNIT_STATE_LIFE, udg_DamageEventTarget)
    udg_DmgStr = "|cffffffff"
    if (Trig_Damage_Tag_Func004C()) then
        if (Trig_Damage_Tag_Func004Func001C()) then
            udg_DmgStr = "|c00AAAAAADODGED!|r"
        else
            if (Trig_Damage_Tag_Func004Func001Func001C()) then
                udg_DmgStr = ("|c00AAAAAABlocked " .. (I2S(R2I((udg_DamageEventPrevAmt * udg_DamageScalingUser))) .. "!|r"))
            else
                udg_DmgStr = ("|c00AAAAAABlocked " .. (I2S(R2I((udg_DamageEventPrevAmt * udg_DamageScalingWC3))) .. "!|r"))
            end
        end
                ArcingTextTag(udg_DmgStr, udg_DamageEventTarget)
    else
        if (Trig_Damage_Tag_Func004Func002C()) then
            udg_DmgStr = "|cff00ff00+"
                        ArcingTextTag(udg_DmgStr .. R2I(-udg_DamageEventAmount) .. "|r", udg_DamageEventTarget)
        else
            if (Trig_Damage_Tag_Func004Func002Func001C()) then
                udg_DmgStr = ("|cffff0000" .. (I2S(R2I(udg_DamageEventAmount)) .. "!|r"))
                                ArcingTextTag(udg_DmgStr, udg_DamageEventTarget)
            else
                if (Trig_Damage_Tag_Func004Func002Func001Func001C()) then
                    if (Trig_Damage_Tag_Func004Func002Func001Func001Func001C()) then
                        udg_DmgStr = "|cff808000"
                    else
                        if (Trig_Damage_Tag_Func004Func002Func001Func001Func001Func001C()) then
                            udg_DmgStr = "|cff3264c8"
                        else
                            if (Trig_Damage_Tag_Func004Func002Func001Func001Func001Func001Func002C()) then
                                udg_DmgStr = "|cffffff00"
                            else
                            end
                        end
                    end
                                        ArcingTextTag(udg_DmgStr .. R2I(udg_DamageEventAmount) .. "|r", udg_DamageEventTarget)
                else
                end
            end
        end
    end
end

function InitTrig_Damage_Tag()
    gg_trg_Damage_Tag = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_Damage_Tag, "udg_DamageEvent", EQUAL, 1.00)
    TriggerAddAction(gg_trg_Damage_Tag, Trig_Damage_Tag_Actions)
end

function Trig_On_AOE_Conditions()
    if (not (true == true)) then
        return false
    end
    return true
end

function Trig_On_AOE_Func002001()
    return (udg_Reporting == false)
end

function Trig_On_AOE_Func004A()
    udg_AOEString = (udg_AOEString .. (GetUnitName(GetEnumUnit()) .. ", "))
end

function Trig_On_AOE_Actions()
    if (Trig_On_AOE_Func002001()) then
        return 
    else
        DoNothing()
    end
    udg_AOEString = (GetUnitName(udg_AOEDamageSource) .. " has dealt AOE damage to ")
    ForGroupBJ(udg_DamageEventAOEGroup, Trig_On_AOE_Func004A)
    DisplayTextToForce(GetPlayersAll(), (SubStringBJ(udg_AOEString, 1, (StringLength(udg_AOEString) - 2)) .. "."))
end

function InitTrig_On_AOE()
    gg_trg_On_AOE = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_On_AOE, "udg_AOEDamageEvent", EQUAL, 1.00)
    TriggerAddCondition(gg_trg_On_AOE, Condition(Trig_On_AOE_Conditions))
    TriggerAddAction(gg_trg_On_AOE, Trig_On_AOE_Actions)
end

function Trig_On_Zero_Conditions()
    if (not (true == true)) then
        return false
    end
    return true
end

function Trig_On_Zero_Actions()
    udg_ReportLife = GetUnitStateSwap(UNIT_STATE_LIFE, udg_DamageEventTarget)
    TriggerExecute(gg_trg_Damage_Report)
end

function InitTrig_On_Zero()
    gg_trg_On_Zero = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_On_Zero, "udg_DamageEvent", EQUAL, 2.00)
    TriggerAddCondition(gg_trg_On_Zero, Condition(Trig_On_Zero_Conditions))
    TriggerAddAction(gg_trg_On_Zero, Trig_On_Zero_Actions)
end

function Trig_Damage_Report_Func001001()
    return (udg_Reporting == false)
end

function Trig_Damage_Report_Func003Func002Func002C()
    if (not (udg_IsDamageRanged == true)) then
        return false
    end
    return true
end

function Trig_Damage_Report_Func003Func002C()
    if (not (udg_IsDamageSpell == true)) then
        return false
    end
    return true
end

function Trig_Damage_Report_Func003C()
    if (not (udg_IsDamageMelee == true)) then
        return false
    end
    return true
end

function Trig_Damage_Report_Func010C()
    if (not (udg_DamageEventLevel > 1)) then
        return false
    end
    return true
end

function Trig_Damage_Report_Actions()
    if (Trig_Damage_Report_Func001001()) then
        return 
    else
        DoNothing()
    end
    DisplayTextToForce(GetPlayersAll(), ("==============" .. (R2S(TimerGetElapsed(udg_Timestamp)) .. "==============")))
    if (Trig_Damage_Report_Func003C()) then
        udg_DmgStr = " Melee damage."
    else
        if (Trig_Damage_Report_Func003Func002C()) then
            udg_DmgStr = " Spell damage."
        else
            if (Trig_Damage_Report_Func003Func002Func002C()) then
                udg_DmgStr = " Ranged damage."
            else
            end
        end
    end
    DisplayTextToForce(GetPlayersAll(), ("REPORT: " .. (GetUnitName(udg_DamageEventSource) .. (" damaged " .. (GetUnitName(udg_DamageEventTarget) .. (" for " .. (R2S(udg_DamageEventPrevAmt) .. (" => " .. (R2S(udg_DamageEventAmount) .. udg_DmgStr)))))))))
    DisplayTextToForce(GetPlayersAll(), ("Attack Type " .. (udg_AttackTypeDebugStr[udg_DamageEventAttackT] .. (" Damage Type " .. (udg_DamageTypeDebugStr[udg_DamageEventDamageT] .. (" Weapon Type " .. udg_WeaponTypeDebugStr[udg_DamageEventWeaponT]))))))
    DisplayTextToForce(GetPlayersAll(), ("Armor Type " .. (udg_ArmorTypeDebugStr[udg_DamageEventArmorT] .. (" Defense Type " .. udg_DefenseTypeDebugStr[udg_DamageEventDefenseT]))))
    DisplayTextToForce(GetPlayersAll(), ("Life chanaged from " .. (R2S(udg_ReportLife) .. (" to " .. R2S(GetUnitStateSwap(UNIT_STATE_LIFE, udg_DamageEventTarget))))))
    DisplayTextToForce(GetPlayersAll(), ("WarCraft 3 increased the damage by  " .. (R2S((100.00 * (udg_DamageScalingWC3 - 1.00))) .. ("% and the user increased it by " .. (R2S((100.00 * (udg_DamageScalingUser - 1.00))) .. "%.")))))
    if (Trig_Damage_Report_Func010C()) then
        DisplayTextToForce(GetPlayersAll(), "TRIGSTR_215")
    else
    end
end

function InitTrig_Damage_Report()
    gg_trg_Damage_Report = CreateTrigger()
    TriggerAddAction(gg_trg_Damage_Report, Trig_Damage_Report_Actions)
end

function Trig_AfterDamageEvent_Actions()
    TriggerExecute(gg_trg_Damage_Report)
end

function InitTrig_AfterDamageEvent()
    gg_trg_AfterDamageEvent = CreateTrigger()
    TriggerRegisterVariableEvent(gg_trg_AfterDamageEvent, "udg_AfterDamageEvent", EQUAL, 1.00)
    TriggerAddAction(gg_trg_AfterDamageEvent, Trig_AfterDamageEvent_Actions)
end

function Trig_Report_On_Off_Actions()
        udg_Reporting = not udg_Reporting
end

function InitTrig_Report_On_Off()
    gg_trg_Report_On_Off = CreateTrigger()
    TriggerRegisterPlayerChatEvent(gg_trg_Report_On_Off, Player(0), "report", true)
    TriggerAddAction(gg_trg_Report_On_Off, Trig_Report_On_Off_Actions)
end

function InitCustomTriggers()
    InitTrig_Damage_Engine_Config()
    InitTrig_StartResources()
    InitTrig_Melee_Initialization()
    InitTrig_DamageOnMovingUnit()
    InitTrig_DamageModifier()
    InitTrig_Prevent_Lethal()
    InitTrig_Is_Unit_Moving()
    InitTrig_Unit_Moving_Index()
    InitTrig_Unit_Indexer_Event()
    InitTrig_Damage_Tag()
    InitTrig_On_AOE()
    InitTrig_On_Zero()
    InitTrig_Damage_Report()
    InitTrig_AfterDamageEvent()
    InitTrig_Report_On_Off()
end

function RunInitializationTriggers()
    ConditionalTriggerExecute(gg_trg_Damage_Engine_Config)
    ConditionalTriggerExecute(gg_trg_StartResources)
    ConditionalTriggerExecute(gg_trg_Melee_Initialization)
end

function InitCustomPlayerSlots()
    SetPlayerStartLocation(Player(0), 0)
    ForcePlayerStartLocation(Player(0), 0)
    SetPlayerColor(Player(0), ConvertPlayerColor(0))
    SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(0), false)
    SetPlayerController(Player(0), MAP_CONTROL_USER)
    SetPlayerStartLocation(Player(1), 1)
    ForcePlayerStartLocation(Player(1), 1)
    SetPlayerColor(Player(1), ConvertPlayerColor(1))
    SetPlayerRacePreference(Player(1), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(1), false)
    SetPlayerController(Player(1), MAP_CONTROL_USER)
    SetPlayerStartLocation(Player(2), 2)
    ForcePlayerStartLocation(Player(2), 2)
    SetPlayerColor(Player(2), ConvertPlayerColor(2))
    SetPlayerRacePreference(Player(2), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(2), false)
    SetPlayerController(Player(2), MAP_CONTROL_USER)
    SetPlayerStartLocation(Player(3), 3)
    ForcePlayerStartLocation(Player(3), 3)
    SetPlayerColor(Player(3), ConvertPlayerColor(3))
    SetPlayerRacePreference(Player(3), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(3), false)
    SetPlayerController(Player(3), MAP_CONTROL_USER)
    SetPlayerStartLocation(Player(4), 4)
    ForcePlayerStartLocation(Player(4), 4)
    SetPlayerColor(Player(4), ConvertPlayerColor(4))
    SetPlayerRacePreference(Player(4), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(4), false)
    SetPlayerController(Player(4), MAP_CONTROL_COMPUTER)
    SetPlayerStartLocation(Player(5), 5)
    ForcePlayerStartLocation(Player(5), 5)
    SetPlayerColor(Player(5), ConvertPlayerColor(5))
    SetPlayerRacePreference(Player(5), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(5), false)
    SetPlayerController(Player(5), MAP_CONTROL_COMPUTER)
    SetPlayerStartLocation(Player(6), 6)
    ForcePlayerStartLocation(Player(6), 6)
    SetPlayerColor(Player(6), ConvertPlayerColor(6))
    SetPlayerRacePreference(Player(6), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(6), false)
    SetPlayerController(Player(6), MAP_CONTROL_COMPUTER)
    SetPlayerStartLocation(Player(7), 7)
    ForcePlayerStartLocation(Player(7), 7)
    SetPlayerColor(Player(7), ConvertPlayerColor(7))
    SetPlayerRacePreference(Player(7), RACE_PREF_HUMAN)
    SetPlayerRaceSelectable(Player(7), false)
    SetPlayerController(Player(7), MAP_CONTROL_COMPUTER)
end

function InitCustomTeams()
    SetPlayerTeam(Player(0), 0)
    SetPlayerState(Player(0), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerTeam(Player(2), 0)
    SetPlayerState(Player(2), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerTeam(Player(4), 0)
    SetPlayerState(Player(4), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerTeam(Player(6), 0)
    SetPlayerState(Player(6), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerAllianceStateAllyBJ(Player(0), Player(2), true)
    SetPlayerAllianceStateAllyBJ(Player(0), Player(4), true)
    SetPlayerAllianceStateAllyBJ(Player(0), Player(6), true)
    SetPlayerAllianceStateAllyBJ(Player(2), Player(0), true)
    SetPlayerAllianceStateAllyBJ(Player(2), Player(4), true)
    SetPlayerAllianceStateAllyBJ(Player(2), Player(6), true)
    SetPlayerAllianceStateAllyBJ(Player(4), Player(0), true)
    SetPlayerAllianceStateAllyBJ(Player(4), Player(2), true)
    SetPlayerAllianceStateAllyBJ(Player(4), Player(6), true)
    SetPlayerAllianceStateAllyBJ(Player(6), Player(0), true)
    SetPlayerAllianceStateAllyBJ(Player(6), Player(2), true)
    SetPlayerAllianceStateAllyBJ(Player(6), Player(4), true)
    SetPlayerAllianceStateVisionBJ(Player(0), Player(2), true)
    SetPlayerAllianceStateVisionBJ(Player(0), Player(4), true)
    SetPlayerAllianceStateVisionBJ(Player(0), Player(6), true)
    SetPlayerAllianceStateVisionBJ(Player(2), Player(0), true)
    SetPlayerAllianceStateVisionBJ(Player(2), Player(4), true)
    SetPlayerAllianceStateVisionBJ(Player(2), Player(6), true)
    SetPlayerAllianceStateVisionBJ(Player(4), Player(0), true)
    SetPlayerAllianceStateVisionBJ(Player(4), Player(2), true)
    SetPlayerAllianceStateVisionBJ(Player(4), Player(6), true)
    SetPlayerAllianceStateVisionBJ(Player(6), Player(0), true)
    SetPlayerAllianceStateVisionBJ(Player(6), Player(2), true)
    SetPlayerAllianceStateVisionBJ(Player(6), Player(4), true)
    SetPlayerAllianceStateControlBJ(Player(0), Player(2), true)
    SetPlayerAllianceStateControlBJ(Player(0), Player(4), true)
    SetPlayerAllianceStateControlBJ(Player(0), Player(6), true)
    SetPlayerAllianceStateControlBJ(Player(2), Player(0), true)
    SetPlayerAllianceStateControlBJ(Player(2), Player(4), true)
    SetPlayerAllianceStateControlBJ(Player(2), Player(6), true)
    SetPlayerAllianceStateControlBJ(Player(4), Player(0), true)
    SetPlayerAllianceStateControlBJ(Player(4), Player(2), true)
    SetPlayerAllianceStateControlBJ(Player(4), Player(6), true)
    SetPlayerAllianceStateControlBJ(Player(6), Player(0), true)
    SetPlayerAllianceStateControlBJ(Player(6), Player(2), true)
    SetPlayerAllianceStateControlBJ(Player(6), Player(4), true)
    SetPlayerTeam(Player(1), 1)
    SetPlayerState(Player(1), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerTeam(Player(3), 1)
    SetPlayerState(Player(3), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerTeam(Player(5), 1)
    SetPlayerState(Player(5), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerTeam(Player(7), 1)
    SetPlayerState(Player(7), PLAYER_STATE_ALLIED_VICTORY, 1)
    SetPlayerAllianceStateAllyBJ(Player(1), Player(3), true)
    SetPlayerAllianceStateAllyBJ(Player(1), Player(5), true)
    SetPlayerAllianceStateAllyBJ(Player(1), Player(7), true)
    SetPlayerAllianceStateAllyBJ(Player(3), Player(1), true)
    SetPlayerAllianceStateAllyBJ(Player(3), Player(5), true)
    SetPlayerAllianceStateAllyBJ(Player(3), Player(7), true)
    SetPlayerAllianceStateAllyBJ(Player(5), Player(1), true)
    SetPlayerAllianceStateAllyBJ(Player(5), Player(3), true)
    SetPlayerAllianceStateAllyBJ(Player(5), Player(7), true)
    SetPlayerAllianceStateAllyBJ(Player(7), Player(1), true)
    SetPlayerAllianceStateAllyBJ(Player(7), Player(3), true)
    SetPlayerAllianceStateAllyBJ(Player(7), Player(5), true)
    SetPlayerAllianceStateVisionBJ(Player(1), Player(3), true)
    SetPlayerAllianceStateVisionBJ(Player(1), Player(5), true)
    SetPlayerAllianceStateVisionBJ(Player(1), Player(7), true)
    SetPlayerAllianceStateVisionBJ(Player(3), Player(1), true)
    SetPlayerAllianceStateVisionBJ(Player(3), Player(5), true)
    SetPlayerAllianceStateVisionBJ(Player(3), Player(7), true)
    SetPlayerAllianceStateVisionBJ(Player(5), Player(1), true)
    SetPlayerAllianceStateVisionBJ(Player(5), Player(3), true)
    SetPlayerAllianceStateVisionBJ(Player(5), Player(7), true)
    SetPlayerAllianceStateVisionBJ(Player(7), Player(1), true)
    SetPlayerAllianceStateVisionBJ(Player(7), Player(3), true)
    SetPlayerAllianceStateVisionBJ(Player(7), Player(5), true)
    SetPlayerAllianceStateControlBJ(Player(1), Player(3), true)
    SetPlayerAllianceStateControlBJ(Player(1), Player(5), true)
    SetPlayerAllianceStateControlBJ(Player(1), Player(7), true)
    SetPlayerAllianceStateControlBJ(Player(3), Player(1), true)
    SetPlayerAllianceStateControlBJ(Player(3), Player(5), true)
    SetPlayerAllianceStateControlBJ(Player(3), Player(7), true)
    SetPlayerAllianceStateControlBJ(Player(5), Player(1), true)
    SetPlayerAllianceStateControlBJ(Player(5), Player(3), true)
    SetPlayerAllianceStateControlBJ(Player(5), Player(7), true)
    SetPlayerAllianceStateControlBJ(Player(7), Player(1), true)
    SetPlayerAllianceStateControlBJ(Player(7), Player(3), true)
    SetPlayerAllianceStateControlBJ(Player(7), Player(5), true)
end

function InitAllyPriorities()
    SetStartLocPrioCount(0, 1)
    SetStartLocPrio(0, 0, 2, MAP_LOC_PRIO_HIGH)
    SetStartLocPrioCount(1, 1)
    SetStartLocPrio(1, 0, 3, MAP_LOC_PRIO_HIGH)
    SetStartLocPrioCount(2, 1)
    SetStartLocPrio(2, 0, 0, MAP_LOC_PRIO_HIGH)
    SetStartLocPrioCount(3, 1)
    SetStartLocPrio(3, 0, 1, MAP_LOC_PRIO_HIGH)
    SetStartLocPrioCount(4, 4)
    SetStartLocPrio(4, 0, 0, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(4, 1, 2, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(4, 2, 3, MAP_LOC_PRIO_LOW)
    SetStartLocPrio(4, 3, 5, MAP_LOC_PRIO_LOW)
    SetEnemyStartLocPrioCount(4, 1)
    SetEnemyStartLocPrio(4, 0, 0, MAP_LOC_PRIO_HIGH)
    SetStartLocPrioCount(5, 4)
    SetStartLocPrio(5, 0, 1, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(5, 1, 2, MAP_LOC_PRIO_LOW)
    SetStartLocPrio(5, 2, 3, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(5, 3, 4, MAP_LOC_PRIO_LOW)
    SetEnemyStartLocPrioCount(5, 1)
    SetEnemyStartLocPrio(5, 0, 6, MAP_LOC_PRIO_LOW)
    SetEnemyStartLocPrioCount(6, 3)
    SetEnemyStartLocPrio(6, 0, 4, MAP_LOC_PRIO_HIGH)
    SetEnemyStartLocPrio(6, 1, 5, MAP_LOC_PRIO_HIGH)
    SetEnemyStartLocPrio(6, 2, 7, MAP_LOC_PRIO_HIGH)
    SetStartLocPrioCount(7, 7)
    SetStartLocPrio(7, 0, 0, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(7, 1, 1, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(7, 2, 3, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(7, 3, 4, MAP_LOC_PRIO_HIGH)
    SetStartLocPrio(7, 4, 5, MAP_LOC_PRIO_LOW)
    SetStartLocPrio(7, 5, 6, MAP_LOC_PRIO_LOW)
end

function main()
    SetCameraBounds(-4096.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -4096.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 8192.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 4096.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -4096.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 4096.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 8192.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -4096.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
    NewSoundEnvironment("Default")
    SetAmbientDaySound("LordaeronSummerDay")
    SetAmbientNightSound("LordaeronSummerNight")
    SetMapMusic("Music", true, 0)
    CreateAllUnits()
    InitBlizzard()
    InitGlobals()
    InitCustomTriggers()
    RunInitializationTriggers()
end

function config()
    SetMapName("TRIGSTR_003")
    SetMapDescription("TRIGSTR_005")
    SetPlayers(8)
    SetTeams(8)
    SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
    DefineStartLocation(0, 5248.0, 3072.0)
    DefineStartLocation(1, 4672.0, -3008.0)
    DefineStartLocation(2, 4992.0, 1600.0)
    DefineStartLocation(3, 4416.0, -1216.0)
    DefineStartLocation(4, 192.0, 2688.0)
    DefineStartLocation(5, 64.0, -2816.0)
    DefineStartLocation(6, 832.0, 3840.0)
    DefineStartLocation(7, 2496.0, -3584.0)
    InitCustomPlayerSlots()
    InitCustomTeams()
    InitAllyPriorities()
end


globals(function(_ENV)
    udg_UnitIndexEvent = 0.0
    udg_AfterDamageEvent = 0.0
    udg_DamageEvent = 0.0
    udg_DamageModifierEvent = 0.0
    udg_LethalDamageEvent = 0.0
    udg_AOEDamageEvent = 0.0
end)

